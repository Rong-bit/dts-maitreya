<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <base target="_top">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>大慈山彌勒道場</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    /* CSS 變數定義 */
    :root {
      --primary-color: #8B4513;
      --primary-hover: #6B3413;
      --secondary-color: #666;
      --background-color: #f5f5f5;
      --text-color: #333;
      --white: #fff;
      --white-transparent: rgba(255, 255, 255, 0.95);
      --white-transparent-98: rgba(255, 255, 255, 0.98);
      --shadow-light: 0 2px 4px rgba(0,0,0,0.1);
      --shadow-medium: 0 4px 8px rgba(0,0,0,0.1);
      --shadow-heavy: 0 4px 12px rgba(0, 0, 0, 0.15);
      --border-radius-small: 5px;
      --border-radius-medium: 8px;
      --border-radius-large: 10px;
      --border-radius-xl: 15px;
      --transition: all 0.3s ease;
      --font-family: "DFKai-SB", "BiauKai", "PingFang TC", "蘋方-繁", "Heiti TC", "黑體-繁", "Microsoft JhengHei", "微軟正黑體", sans-serif;
    }

    /* 重置所有元素的預設樣式 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* 頁面主體樣式 */
    body {
      font-family: "DFKai-SB", "BiauKai", "PingFang TC", "蘋方-繁", "Heiti TC", "黑體-繁", "Microsoft JhengHei", "微軟正黑體", sans-serif;
      line-height: 1.6;
      background-color: #f5f5f5;
      color: #333;
      background-image: url('https://img.freepik.com/free-photo/old-paper-texture_1194-5415.jpg');
      background-size: cover;
      background-attachment: fixed;
      font-size: 18px;
    }

    /* 主容器樣式 */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 30px;
    }

    /* 頁首樣式 */
    header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px 0;
      border-bottom: 3px solid #8B4513;
      background-color: rgba(255, 255, 255, 0.95);
      border-radius: 15px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    /* 標題樣式 */
    h1 {
      color: #8B4513;
      font-size: 3em;
      margin-bottom: 20px;
      font-weight: bold;
    }

    /* 副標題樣式 */
    .subtitle {
      color: #666;
      font-size: 1.5em;
      font-style: italic;
    }

    /* 導航列樣式 */
    .navigation {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 40px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    /* 導航按鈕樣式 */
    .nav-button {
      padding: 15px 30px;  /* 上下15px，左右30px的內邊距 */
      background-color: #fff;
      border: 2px solid #8B4513;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      color: #8B4513;
      font-weight: bold;
      font-size: 1.2em;
    }

    /* 導航按鈕懸停效果 */
    .nav-button:hover {
      background-color: #8B4513;
      color: white;
    }

    /* 當前選中的導航按鈕樣式 */
    .nav-button.active {
      background-color: #8B4513;
      color: white;
    }

    /* 進階控制區域樣式 */
    .advanced-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
      margin-bottom: 20px;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* 搜尋容器樣式 */
    .search-container {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      max-width: 400px;
    }

    .search-input {
      flex: 1;
      padding: 10px 15px;
      border: 2px solid #8B4513;
      border-radius: 8px;
      font-size: 16px;
      font-family: var(--font-family);
      transition: all 0.3s ease;
    }

    .search-input:focus {
      outline: none;
      border-color: #6B3413;
      box-shadow: 0 0 5px rgba(139, 69, 19, 0.3);
    }

    .search-btn, .search-clear-btn {
      padding: 10px 15px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 16px;
    }

    .search-btn:hover, .search-clear-btn:hover {
      background-color: #6B3413;
    }

    /* 工具按鈕樣式 */
    .utility-buttons {
      display: flex;
      gap: 10px;
    }

    .utility-btn {
      padding: 10px 20px;
      background-color: #fff;
      border: 2px solid #8B4513;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      color: #8B4513;
      font-weight: bold;
      font-size: 14px;
      font-family: var(--font-family);
    }

    .utility-btn:hover {
      background-color: #8B4513;
      color: white;
    }

    /* 搜尋結果高亮樣式 */
    .sutra-line.search-match {
      background-color: rgba(255, 255, 0, 0.3);
      border: 2px solid #ffd700;
    }

    .sutra-line.search-match .original-text {
      position: relative;
    }

    /* 書籤標記樣式 */
    .sutra-line.bookmarked::before {
      content: "\f02e";
      font-family: "Font Awesome 6 Free";
      font-weight: 900;
      position: absolute;
      right: 10px;
      top: 10px;
      color: #ffd700;
      font-size: 20px;
    }

    .sutra-line {
      position: relative;
    }

    /* 內容區域樣式 */
    .content {
      background-color: rgba(255, 255, 255, 0.95);
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }

    /* 章節內容樣式 */
    .chapter-content {
      display: none;
      margin: 0;
      padding: 0;
    }

    .chapter-content.active {
      display: block;
    }

    /* 章節標題樣式 */
    .chapter-title {
      color: #8B4513;
      font-size: 1.8em;
      margin: 0;
      padding: 10px;
      border-bottom: 2px solid #8B4513;
      text-align: center;
    }

    /* 經文行樣式 */
    .sutra-line {
      padding: 15px;  /* 減少手機版的內邊距 */
      margin-bottom: 20px;  /* 減少行間距 */
      max-width: 100%;  /* 使用全寬 */
      border: 2px solid #8B4513;  /* 確保邊框在手機上顯示 */
      border-radius: 8px;  /* 手機版圓角稍小 */
      background-color: rgba(255, 255, 255, 0.95);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    /* 經文行懸停效果 */
    .sutra-line:hover {
      background-color: rgba(139, 69, 19, 0.1);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }

    /* 選中的經文行樣式（點擊選中，適中底色） */
    .sutra-line.selected {
      background-color: rgba(139, 69, 19, 0.15);
      border: 2px solid #8B4513;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(139, 69, 19, 0.2);
      transition: all 0.3s ease;
    }

    /* 正在朗讀的經文行樣式（深色底色） */
    .sutra-line.reading {
      background-color: rgba(139, 69, 19, 0.3);
      border: 2px solid #8B4513;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(139, 69, 19, 0.2);
      transition: all 0.3s ease;
    }

    /* 正在朗讀的原文樣式 */
    .sutra-line.reading .original-text {
      color: #000;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 顯示翻譯時的經文行樣式 */
    .sutra-line.translation-active {
      background-color: rgba(139, 69, 19, 0.05);
      border: 2px solid #8B4513;
      transform: translateY(-3px);
      box-shadow: 0 8px 16px rgba(139, 69, 19, 0.2);
      transition: all 0.3s ease;
    }

    /* 顯示翻譯時的原文樣式 */
    .sutra-line.translation-active .original-text {
      color: #222;
      font-weight: bold;
      text-shadow: none;
    }

    /* 同時朗讀和翻譯時的經文行樣式（朗讀優先） */
    .sutra-line.reading.translation-active {
      background-color: rgba(139, 69, 19, 0.3) !important;
      border: 2px solid #8B4513;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(139, 69, 19, 0.2);
      transition: all 0.3s ease;
    }

    /* 同時選中和翻譯時的經文行樣式（選中優先） */
    .sutra-line.selected.translation-active {
      background-color: rgba(139, 69, 19, 0.15);
      border: 2px solid #8B4513;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(139, 69, 19, 0.2);
      transition: all 0.3s ease;
    }

    /* 同時朗讀和翻譯時的原文樣式（朗讀優先） */
    .sutra-line.reading.translation-active .original-text {
      color: #000;
      font-weight: bold;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 原文樣式 */
    .original-text {
      font-size: 1.6em;
      margin-bottom: 15px;
      cursor: pointer;
      color: #222;
      font-weight: bold;
      line-height: 2.2;
      letter-spacing: 0.5px;
      text-align: center;
      max-width: 100%;
      display: block;
      padding: 5px 10px;
      white-space: pre-line;
      word-wrap: break-word;
      transition: all 0.3s ease;
      position: relative;
    }

    /* 原文懸停效果 */
    .original-text:hover {
      color: #8B4513;
      text-shadow: 0 1px 2px rgba(139, 69, 19, 0.1);
    }

    /* 顯示翻譯時的原文懸停效果（與一般懸停相同） */
    .sutra-line.translation-active .original-text:hover {
      color: #8B4513;
      text-shadow: 0 1px 2px rgba(139, 69, 19, 0.1);
    }

    /* 同時朗讀和翻譯時的原文懸停效果（保持黑色） */
    .sutra-line.reading.translation-active .original-text:hover {
      color: #000;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    /* 原文點擊提示 - 只在有翻譯時顯示 */
    .original-text.has-translation::after {
      content: '點擊看翻譯';
      position: absolute;
      bottom: -25px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.8em;
      color: #8B4513;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 1px 8px;
      border-radius: 4px;
      white-space: nowrap;
      line-height: 1.2;
    }

    .original-text.has-translation:hover::after {
      opacity: 1;
    }

    /* 工作表數字列提示 - 所有經文行都顯示 */
    .original-text::before {
      content: '第 ' attr(data-sheet-row) ' 行';
      position: absolute;
      top: -30px;
      right: 10px;
      font-size: 0.8em;
      color: #8B4513;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      background-color: rgba(255, 255, 255, 0.95);
      padding: 3px 8px;
      border-radius: 4px;
      white-space: nowrap;
      line-height: 1.2;
      border: 1px solid #8B4513;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* 當行號為0時不顯示提示 */
    .original-text[data-sheet-row="0"]::before {
      display: none;
    }

    .original-text:hover::before {
      opacity: 1;
    }

    /* 有翻譯的經文行樣式 */
    .sutra-line.has-translation {
      cursor: pointer;
    }

    /* 沒有翻譯的經文行樣式 - 使用與 has-translation 相同的樣式，無需額外覆蓋 */

    /* 翻譯樣式 */
    .translation {
      display: none;
      font-size: 1.5em;
      color: #333;
      padding: 20px 15px;
      background-color: rgba(255, 255, 255, 0.98);
      border-radius: 10px;
      margin-top: 15px;
      border-left: 5px solid #8B4513;
      line-height: 2;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      font-weight: 500;
      letter-spacing: 0.3px;
      white-space: pre-line;
      max-width: 100%;
      width: 100%;
      word-wrap: break-word;
      text-align: left;
      margin-left: auto;
      margin-right: auto;
      box-sizing: border-box;
    }

    /* 顯示翻譯的動畫效果 */
    .translation.show {
      display: block !important;
      animation: fadeIn 0.3s ease;
    }

    /* 淡入動畫定義 */
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* 回到頂部按鈕樣式 */
    .back-to-top {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 40px;
      height: 40px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: none;
      transition: all 0.3s ease;
      font-size: 1.2em;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .back-to-top:hover {
      background-color: #6B3413;
      box-shadow: 0 2px 8px rgba(139, 69, 19, 0.3);
    }

    /* 手機版回到頂部按鈕樣式 */
    @media (max-width: 768px) {
      .back-to-top {
        width: 35px;
        height: 35px;
        font-size: 1em;
        bottom: 100px; /* 進一步調整位置，確保不被播放控制面板覆蓋 */
        right: 20px;
        z-index: 1001; /* 確保在播放控制面板之上 */
      }
    }

    /* 響應式佈局 - 行動裝置樣式 */
    @media (max-width: 768px) {
      body {
        font-size: 16px;
        font-family: "DFKai-SB", "標楷體", "KaiTi", "楷体", "Microsoft JhengHei", "微軟正黑體", sans-serif;
      }
      
      .container {
        padding: 15px;
      }

      .content {
        padding: 15px;
      }

      .sutra-line {
        padding: 15px;  /* 減少手機版的內邊距 */
        margin-bottom: 20px;  /* 減少行間距 */
        max-width: 100%;  /* 使用全寬 */
      }

      .original-text {
        font-size: 1.4em;  /* 稍微減小字體 */
        letter-spacing: 0.3px;  /* 減少字元間距 */
        line-height: 2;  /* 減少行高 */
        font-family: "DFKai-SB", "標楷體", "KaiTi", "楷体", "Microsoft JhengHei", "微軟正黑體", sans-serif;
      }

      /* 手機版隱藏點擊提示 */
      .original-text::after {
        display: none;
      }

      .translation {
        font-size: 1.3em;  /* 稍微減小字體 */
        padding: 20px;  /* 減少內邊距 */
        line-height: 1.8;  /* 減少行高 */
        font-family: "DFKai-SB", "標楷體", "KaiTi", "楷体", "Microsoft JhengHei", "微軟正黑體", sans-serif;
      }

      /* 手機版顯示翻譯時的經文行樣式 */
      .sutra-line.translation-active {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(139, 69, 19, 0.15);
      }

      /* 手機版正在朗讀的經文行樣式 */
      .sutra-line.selected {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(139, 69, 19, 0.2);
      }

      /* 手機版同時朗讀和翻譯時的經文行樣式（朗讀優先） */
      .sutra-line.selected.translation-active {
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(139, 69, 19, 0.2);
      }

      h1 {
        font-size: 2.5em;
        font-family: "DFKai-SB", "標楷體", "KaiTi", "楷体", "Microsoft JhengHei", "微軟正黑體", sans-serif;
      }
    }

    /* 字體大小控制區域樣式 */
    .font-size-controls {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    /* 字體大小滑塊容器樣式 */
    .font-size-slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* 字體大小按鈕樣式 */
    .font-size-btn {
      width: 30px;
      height: 30px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .font-size-btn:hover {
      background-color: #6B3413;
      box-shadow: 0 2px 8px rgba(139, 69, 19, 0.3);
    }

    .font-size-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    /* 字體大小標籤樣式 */
    .font-size-label {
      color: #8B4513;
      font-weight: bold;
    }



    /* 字體大小顯示值樣式 */
    .font-size-value {
      min-width: 30px;
      text-align: center;
      color: #8B4513;
      font-weight: bold;
    }

    /* 小字體樣式 */
    .font-small {
      font-size: 16px;
    }

    /* 中等字體樣式 */
    .font-medium {
      font-size: 18px;
    }

    /* 大字體樣式 */
    .font-large {
      font-size: 20px;
    }

    /* 小字體下的原文樣式 */
    .font-small .original-text {
      font-size: 1.6em;
    }

    /* 中等字體下的原文樣式 */
    .font-medium .original-text {
      font-size: 1.8em;
    }

    /* 大字體下的原文樣式 */
    .font-large .original-text {
      font-size: 2.0em;
    }

    /* 小字體下的翻譯樣式 */
    .font-small .translation {
      font-size: 1.5em;
    }

    /* 中等字體下的翻譯樣式 */
    .font-medium .translation {
      font-size: 1.7em;
    }

    /* 大字體下的翻譯樣式 */
    .font-large .translation {
      font-size: 1.9em;
    }

    /* 同音字控制區域樣式 */
    .homophone-controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      justify-content: center;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    /* 同音字切換按鈕樣式 */
    .homophone-toggle {
      padding: 10px 20px;
      background-color: #fff;
      border: 2px solid #8B4513;
      border-radius: 6px;
      color: #8B4513;
      cursor: pointer;
      font-size: 1em;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    /* 同音字切換按鈕懸停效果 */
    .homophone-toggle:hover {
      background-color: rgba(139, 69, 19, 0.1);
    }

    /* 當前選中的同音字切換按鈕樣式 */
    .homophone-toggle.active {
      background-color: #8B4513;
      color: white;
    }

    /* 同音字容器樣式 */
    .homophone-container {
      position: relative;
      display: inline-block;
      margin: 0 2px;
      text-align: center;
    }

    /* 同音字文字樣式 */
    .homophone-text {
      position: absolute;
      bottom: -1.2em;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.6em;
      color: #8B4513;
      opacity: 0.9;
      white-space: nowrap;
      background-color: transparent;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .sutra-selector {
      margin: 20px 0;
      text-align: center;
      display: flex;
      justify-content: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .sutra-select, .chapter-select {
      padding: 10px 20px;
      font-size: 1.2em;
      border: 2px solid #8B4513;
      border-radius: 8px;
      background-color: white;
      color: #8B4513;
      cursor: pointer;
      min-width: 200px;
    }

    .sutra-select:focus, .chapter-select:focus {
      outline: none;
      box-shadow: 0 0 5px rgba(139, 69, 19, 0.5);
    }

    /* 朗讀按鈕樣式 */
    .read-button {
      padding: 8px 15px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      margin: 5px;
      transition: all 0.3s ease;
    }

    .read-button:hover {
      background-color: #6B3413;
    }

    .read-button.active {
      background-color: #4B2413;
    }

    /* 朗讀控制區域樣式 */
    .read-controls {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
    }

    /* 語速控制樣式 */
    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 8px 15px;
      border-radius: 5px;
      margin: 5px;
    }

    .speed-label {
      color: #8B4513;
      font-weight: bold;
      white-space: nowrap;
    }

    .speed-button {
      width: 30px;
      height: 30px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .speed-button:hover {
      background-color: #6B3413;
      box-shadow: 0 2px 8px rgba(139, 69, 19, 0.3);
    }

    .speed-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .speed-value {
      min-width: 40px;
      text-align: center;
      color: #8B4513;
      font-weight: bold;
    }

    .reading-control-panel .speed-control {
      margin: 0;
      padding: 0 10px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .reading-control-panel .speed-label {
      color: #8B4513;
      font-weight: bold;
      font-size: 0.9em;
    }

    .reading-control-panel .speed-button {
      width: 25px;
      height: 25px;
      font-size: 1em;
    }

    .reading-control-panel .speed-value {
      min-width: 35px;
      text-align: center;
      color: #8B4513;
      font-weight: bold;
      font-size: 0.9em;
    }

    /* 朗讀控制面板樣式 */
    .reading-control-panel {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 12px 20px; /* 調整內邊距 */
      border-radius: 30px; /* 增大圓角 */
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      display: flex;
      align-items: center;
      gap: 12px; /* 調整間距 */
      z-index: 1000;
      border: 2px solid #8B4513;
      font-size: 18px !important; /* 調整字體大小 */
      min-width: 320px; /* 增大最小寬度 */
      max-width: 95vw; /* 最大寬度為視窗寬度的95% */
      flex-wrap: nowrap; /* 防止換行 */
    }

    /* 確保播放界面的所有子元素都不會繼承全局字體大小 */
    .reading-control-panel * {
      font-size: inherit !important;
    }

    .reading-control-panel .read-button {
      margin: 0;
      padding: 8px; /* 增大內邊距 */
      font-size: 1.4em; /* 增大字體大小 */
      width: 44px; /* 增大按鈕 */
      height: 44px; /* 增大按鈕 */
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: #8B4513;
      color: white;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .reading-control-panel .read-button:hover {
      background-color: #6B3413;
      transform: scale(1.1);
    }

    .reading-control-panel .read-button.active {
      background-color: #4B2413;
    }

    .reading-control-panel .speed-control {
      margin: 0;
      padding: 0 8px; /* 增大內邊距 */
      display: flex;
      align-items: center;
      gap: 4px; /* 增大間距 */
    }

    .reading-control-panel .speed-label {
      color: #8B4513;
      font-weight: bold;
      font-size: 1em; /* 增大字體大小 */
      margin-right: 4px; /* 增大右邊距 */
    }

    .reading-control-panel .speed-button {
      width: 28px; /* 增大按鈕 */
      height: 28px; /* 增大按鈕 */
      font-size: 1.1em; /* 增大字體大小 */
    }

    .reading-control-panel .speed-value {
      min-width: 36px; /* 增大最小寬度 */
      text-align: center;
      color: #8B4513;
      font-weight: bold;
      font-size: 1em; /* 增大字體大小 */
      margin: 0 2px; /* 增大左右邊距 */
    }

    /* 手機版朗讀控制面板樣式 */
    @media (max-width: 768px) {
      .reading-control-panel {
        bottom: 15px;
        padding: 6px 12px; /* 減少內邊距 */
        gap: 6px; /* 減少間距 */
        font-size: 14px !important; /* 減少字體大小 */
        min-width: 350px; /* 增大最小寬度 */
        max-width: 99vw; /* 增大最大寬度 */
        flex-wrap: nowrap; /* 防止換行 */
      }

      .reading-control-panel .read-button {
        width: 36px; /* 手機版調整按鈕大小 */
        height: 36px; /* 手機版調整按鈕大小 */
        font-size: 1.2em; /* 調整字體大小 */
      }

      .reading-control-panel .speed-control {
        padding: 0 4px; /* 減少內邊距 */
        gap: 2px; /* 減少間距 */
      }

      .reading-control-panel .speed-label {
        color: #8B4513;
        font-weight: bold;
        font-size: 0.9em; /* 減少字體大小 */
        margin-right: 2px; /* 減少右邊距 */
      }

      .reading-control-panel .speed-button {
        width: 24px; /* 手機版調整按鈕大小 */
        height: 24px; /* 手機版調整按鈕大小 */
        font-size: 0.9em; /* 減少字體大小 */
      }

      .reading-control-panel .speed-value {
        min-width: 28px; /* 減少最小寬度 */
        text-align: center;
        color: #8B4513;
        font-weight: bold;
        font-size: 0.9em; /* 減少字體大小 */
        margin: 0 1px; /* 減少左右邊距 */
      }

      .reading-control-panel .repeat-control {
        padding: 0 4px; /* 減少內邊距 */
        gap: 2px; /* 減少間距 */
        min-width: 120px; /* 設置最小寬度確保完整顯示 */
      }

      .reading-control-panel .repeat-label {
        font-size: 0.85em; /* 減少字體大小 */
        white-space: nowrap; /* 防止換行 */
      }

      .reading-control-panel .repeat-input {
        min-width: 35px; /* 減少最小寬度 */
        font-size: 0.85em; /* 減少字體大小 */
        padding: 1px 2px; /* 減少內邊距 */
      }

      .reading-control-panel .repeat-unit {
        font-size: 0.85em; /* 減少字體大小 */
        white-space: nowrap; /* 防止換行 */
      }

      .reading-control-panel .repeat-infinite-btn {
        padding: 2px 4px; /* 減少內邊距 */
        font-size: 0.8em; /* 減少字體大小 */
        min-width: 20px; /* 減少最小寬度 */
        height: 20px; /* 減少高度 */
        display: flex; /* 確保按鈕顯示 */
        align-items: center; /* 垂直居中 */
        justify-content: center; /* 水平居中 */
      }
    }

    /* 超小螢幕手機版朗讀控制面板樣式 */
    @media (max-width: 480px) {
      .reading-control-panel {
        padding: 4px 8px; /* 進一步減少內邊距 */
        gap: 4px; /* 進一步減少間距 */
        font-size: 12px !important; /* 進一步減少字體大小 */
        min-width: 320px; /* 調整最小寬度 */
      }

      .reading-control-panel .read-button {
        width: 32px; /* 進一步減少按鈕大小 */
        height: 32px; /* 進一步減少按鈕大小 */
        font-size: 1.1em; /* 調整字體大小 */
      }

      .reading-control-panel .speed-control {
        padding: 0 2px; /* 進一步減少內邊距 */
        gap: 1px; /* 進一步減少間距 */
      }

      .reading-control-panel .speed-label {
        font-size: 0.8em; /* 進一步減少字體大小 */
        margin-right: 1px; /* 進一步減少右邊距 */
      }

      .reading-control-panel .speed-button {
        width: 20px; /* 進一步減少按鈕大小 */
        height: 20px; /* 進一步減少按鈕大小 */
        font-size: 0.8em; /* 進一步減少字體大小 */
      }

      .reading-control-panel .speed-value {
        min-width: 24px; /* 進一步減少最小寬度 */
        font-size: 0.8em; /* 進一步減少字體大小 */
        margin: 0; /* 移除邊距 */
      }

      .reading-control-panel .repeat-control {
        padding: 0 2px; /* 進一步減少內邊距 */
        gap: 1px; /* 進一步減少間距 */
        min-width: 100px; /* 調整最小寬度 */
      }

      .reading-control-panel .repeat-label {
        font-size: 0.75em; /* 進一步減少字體大小 */
      }

      .reading-control-panel .repeat-input {
        min-width: 30px; /* 進一步減少最小寬度 */
        font-size: 0.75em; /* 進一步減少字體大小 */
        padding: 0 1px; /* 進一步減少內邊距 */
      }

      .reading-control-panel .repeat-unit {
        font-size: 0.75em; /* 進一步減少字體大小 */
      }

      .reading-control-panel .repeat-infinite-btn {
        padding: 1px 3px; /* 進一步減少內邊距 */
        font-size: 0.7em; /* 進一步減少字體大小 */
        min-width: 18px; /* 進一步減少最小寬度 */
        height: 18px; /* 進一步減少高度 */
      }
    }

    /* 語音控制區域樣式 */
    .voice-control {
      display: flex;
      align-items: center;
      gap: 8px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .voice-label {
      color: #8B4513;
      font-weight: bold;
    }

    .voice-select {
      padding: 4px 8px;
      border: 1px solid #8B4513;
      border-radius: 4px;
      color: #8B4513;
      background-color: white;
      font-size: 1em;
      min-width: 150px;
    }

    /* 手機版樣式調整 */
    @media (max-width: 768px) {
      .font-size-controls {
        gap: 10px;
      }
      
      .font-size-btn {
        width: 28px;
        height: 28px;
        font-size: 1.1em;
      }
      
      .voice-control {
        padding: 8px 15px;
      }
      
      .voice-select {
        min-width: 120px;
        font-size: 0.9em;
      }

      /* 進階控制區域手機版樣式 */
      .advanced-controls {
        flex-direction: column;
        gap: 10px;
        padding: 12px;
      }

      .search-container {
        width: 100%;
        max-width: 100%;
        flex-direction: row;
      }

      .search-input {
        font-size: 16px; /* 防止 iOS 自動縮放 */
        padding: 12px;
      }

      .search-btn, .search-clear-btn {
        padding: 12px 16px;
        min-width: 44px; /* 觸控友好尺寸 */
        min-height: 44px;
        font-size: 18px;
      }

      .utility-buttons {
        width: 100%;
        justify-content: space-around;
      }

      .utility-btn {
        flex: 1;
        padding: 12px 16px;
        min-height: 44px; /* 觸控友好尺寸 */
        font-size: 16px;
        margin: 0 5px;
      }
    }

    /* 超小螢幕手機版進階控制樣式 */
    @media (max-width: 480px) {
      .advanced-controls {
        padding: 10px;
      }

      .search-input {
        font-size: 16px;
        padding: 10px;
      }

      .utility-btn {
        font-size: 14px;
        padding: 10px 12px;
        min-height: 40px;
      }
    }

    /* 行號樣式 */
    .line-number {
      color: #8B4513;
      font-weight: bold;
      margin-right: 8px;
      user-select: none;
    }

    /* 重複控制區域樣式 */
    .repeat-control {
      display: flex;
      align-items: center;
      gap: 10px;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 8px 15px;
      border-radius: 5px;
      margin: 5px;
    }

    .repeat-label {
      color: #8B4513;
      font-weight: bold;
    }

    .repeat-input {
      padding: 4px 8px;
      border: 1px solid #8B4513;
      border-radius: 4px;
      color: #8B4513;
      background-color: white;
      font-size: 1em;
      min-width: 50px;
    }

    .repeat-unit {
      color: #8B4513;
      font-weight: bold;
    }

    .repeat-infinite-btn {
      padding: 4px 8px;
      background-color: #8B4513;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
      transition: all 0.3s ease;
    }

    .repeat-infinite-btn:hover {
      background-color: #A0522D;
      transform: scale(1.05);
    }

    .repeat-infinite-btn.active {
      background-color: #CD853F;
    }

    .reading-control-panel .repeat-control {
      padding: 0 8px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .reading-control-panel .repeat-label {
      color: #8B4513;
      font-weight: bold;
      font-size: 1em;
      white-space: nowrap;
    }

    .reading-control-panel .repeat-input {
      min-width: 45px;
      font-size: 1em;
      padding: 2px 4px;
      text-align: center;
    }

    .reading-control-panel .repeat-unit {
      color: #8B4513;
      font-weight: bold;
      font-size: 1em;
      white-space: nowrap;
    }

    .reading-control-panel .repeat-infinite-btn {
      padding: 4px 6px;
      font-size: 0.9em;
      min-width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .reading-control-panel .speed-control {
      padding: 0 4px; /* 減少內邊距 */
      gap: 0; /* 設置間距為0 */
    }

    .reading-control-panel .speed-label {
      color: #8B4513;
      font-weight: bold;
      font-size: 0.8em; /* 固定字體大小 */
      margin-right: 3px; /* 添加右邊距 */
    }

    .reading-control-panel .speed-button {
      width: 20px; /* 手機版更小的按鈕 */
      height: 20px; /* 手機版更小的按鈕 */
      font-size: 0.8em; /* 固定字體大小 */
    }

    .reading-control-panel .speed-value {
      min-width: 28px; /* 減少最小寬度 */
      text-align: center;
      color: #8B4513;
      font-weight: bold;
      font-size: 0.8em; /* 固定字體大小 */
      margin: 0 1px; /* 添加左右邊距 */
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>大慈山彌勒道場</h1>
      <p class="subtitle">佛經閱讀與翻譯</p>
      <div class="sutra-selector">
        <select class="sutra-select" id="sutraSelect" onchange="changeSutra(this.value)">
          <option value="">載入中...</option>
        </select>
        <select class="chapter-select" id="chapterSelect" onchange="handleChapterChange(this.value)">
          <option value="">請選擇品名</option>
        </select>
      </div>
      <div class="font-size-controls">
        <div class="font-size-slider-container">
          <span class="font-size-label">小</span>
          <button class="font-size-btn" onclick="decreaseFontSize()" title="減小字體">-</button>
          <span class="font-size-value">字體大小</span>
          <button class="font-size-btn" onclick="increaseFontSize()" title="增大字體">+</button>
          <span class="font-size-label">大</span>
        </div>
        <div class="voice-control">
          <span class="voice-label">語音</span>
          <select class="voice-select" id="voiceSelect" onchange="updateVoice(this.value)" onclick="handleVoiceSelectClick()">
            <option value="">載入中...</option>
          </select>
        </div>
      </div>
      <div class="advanced-controls">
        <div class="search-container">
          <input type="text" id="searchInput" class="search-input" placeholder="搜尋經文內容..." onkeyup="handleSearchInput(this.value)">
          <button class="search-btn" onclick="performSearch()" title="搜尋">
            <i class="fas fa-search"></i>
          </button>
          <button class="search-clear-btn" onclick="clearSearch()" title="清除搜尋" style="display: none;">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="utility-buttons">
          <button class="utility-btn" onclick="showBookmarks()" title="書籤管理">
            <i class="fas fa-bookmark"></i> 書籤
          </button>
          <button class="utility-btn" onclick="restoreReadingProgress()" title="恢復閱讀進度">
            <i class="fas fa-history"></i> 進度
          </button>
        </div>
      </div>
    </header>
    
    <div class="content" id="content">
      <!-- 內容將動態載入 -->
      <div id="loading-message" style="text-align: center; padding: 50px; color: #666;">
        <p>正在載入經文列表...</p>
      </div>
    </div>
    
    <button class="back-to-top" onclick="scrollToTop()" title="回到頂部">
      <i class="fas fa-arrow-up"></i>
    </button>
  </div>

  <div class="reading-control-panel">
    <button class="read-button" onclick="toggleReading(this)" title="開始朗讀">
      <i class="fas fa-play"></i>
    </button>
    <button class="read-button" onclick="stopReading()" title="停止朗讀">
      <i class="fas fa-stop"></i>
    </button>
    <div class="speed-control">
      <span class="speed-label">語速</span>
      <button class="speed-button" onclick="decreaseSpeed()" title="減慢語速">-</button>
      <span class="speed-value">0.8x</span>
      <button class="speed-button" onclick="increaseSpeed()" title="加快語速">+</button>
    </div>
    <div class="repeat-control">
      <span class="repeat-label">次數</span>
      <input type="number" min="1" max="999" value="1" class="repeat-input" id="repeatInput" onchange="updateRepeatCount(this.value)" onblur="validateRepeatInput(this)">
      <span class="repeat-unit">次</span>
      <button class="repeat-infinite-btn" onclick="setInfiniteRepeat()" title="設置無限循環">∞</button>
    </div>
  </div>

  <!-- Google Apps Script 模板數據注入 -->
  <script id="template-data" type="application/json"><?!= JSON.stringify(sheetNames || []) ?></script>
  
  <script>
    // 預載入的工作表名稱（從後端傳遞）
    // 從模板數據中讀取，如果模板未處理則使用默認值
    var sheetNames = [];
    try {
      var templateDataEl = document.getElementById('template-data');
      if (templateDataEl && templateDataEl.textContent && templateDataEl.textContent.trim()) {
        var templateContent = templateDataEl.textContent.trim();
        // 檢查是否包含模板語法（未處理的情況）
        if (templateContent.indexOf('<?!=') === -1) {
          sheetNames = JSON.parse(templateContent);
        } else {
          // 模板語法未被處理，使用默認值
          console.warn('模板語法未處理，使用默認值');
          sheetNames = [];
        }
      }
    } catch (e) {
      console.warn('讀取模板數據失敗，使用默認值:', e);
      sheetNames = [];
    }
    console.log('從模板載入的工作表名稱:', sheetNames);
    
    // 兼容性檢測
    function checkBrowserCompatibility() {
      const issues = [];
      
      // 檢查是否為 IE 瀏覽器
      const userAgent = navigator.userAgent;
      const isIE = userAgent.indexOf('MSIE') !== -1 || userAgent.indexOf('Trident/') !== -1;
      
      if (isIE) {
        // IE 瀏覽器顯示完整的不兼容頁面
        document.body.innerHTML = `
          <div style="text-align: center; padding: 50px; font-family: Arial, sans-serif; background-color: #f5f5f5; min-height: 100vh;">
            <div style="background: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); max-width: 600px; margin: 0 auto;">
              <h2 style="color: #8B4513; margin-bottom: 20px;">瀏覽器不兼容</h2>
              <p style="margin-bottom: 20px; line-height: 1.6;">很抱歉，Internet Explorer 瀏覽器已不再受支持，無法正常使用此佛經閱讀系統。</p>
              <p style="margin-bottom: 30px; line-height: 1.6;">請使用以下現代瀏覽器之一：</p>
              <ul style="text-align: left; display: inline-block; line-height: 2;">
                <li><strong>Google Chrome</strong> - 推薦使用</li>
                <li><strong>Microsoft Edge</strong> - Windows 10/11 內建</li>
                <li><strong>Mozilla Firefox</strong></li>
                <li><strong>Safari</strong> - Mac 用戶</li>
              </ul>
              <p style="margin-top: 30px; color: #666; font-size: 14px;">
                建議使用最新版本的 Microsoft Edge 瀏覽器，它提供了最佳的兼容性和性能。
              </p>
            </div>
          </div>
        `;
        return false;
      }
      
      // 檢查 ES6 支持
      try {
        eval('const test = () => {};');
      } catch (e) {
        issues.push('瀏覽器不支持 ES6 語法');
      }
      
      // 檢查 Promise 支持
      if (typeof Promise === 'undefined') {
        issues.push('瀏覽器不支持 Promise');
      }
      
      // 檢查 async/await 支持
      try {
        eval('async function test() {}');
      } catch (e) {
        issues.push('瀏覽器不支持 async/await');
      }
      
      // 檢查語音合成支持
      if (typeof window.speechSynthesis === 'undefined') {
        issues.push('瀏覽器不支持語音合成功能');
      }
      
      // 如果有兼容性問題，顯示警告
      if (issues.length > 0) {
        const warningDiv = document.createElement('div');
        warningDiv.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          background-color: #ff6b6b;
          color: white;
          padding: 10px;
          text-align: center;
          z-index: 10000;
          font-size: 14px;
        `;
        warningDiv.innerHTML = `
          <strong>兼容性警告：</strong> ${issues.join('、')}。
          <br>建議使用 Chrome、Safari 或 Firefox 最新版本。
          <button onclick="this.parentElement.remove()" style="margin-left: 10px; padding: 5px 10px; background: white; color: #ff6b6b; border: none; border-radius: 3px; cursor: pointer;">關閉</button>
        `;
        document.body.appendChild(warningDiv);
      }
      
      return issues.length === 0;
    }
    
    // 頁面載入時檢查兼容性
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', checkBrowserCompatibility);
    } else {
      checkBrowserCompatibility();
    }
    
    // 配置常數
    const CONFIG = {
      CACHE_DURATION: 5 * 60 * 1000, // 5分鐘緩存
      SPEECH_TIMEOUT: 10000, // 10秒超時
      FONT_SIZE_MIN: 16,
      FONT_SIZE_MAX: 48,
      FONT_SIZE_DEFAULT: 18,
      SPEED_MIN: 0.5,
      SPEED_MAX: 2.0,
      SPEED_DEFAULT: 0.8,
      REPEAT_MAX: 999,
      REPEAT_DEFAULT: 1,
      ANIMATION_DURATION: 300,
      AUTO_HIDE_DELAY: 5000
    };

    // 狀態管理
    const STATE = {
      isSpeechSynthesisReady: false,
      isSpeechSynthesisSupported: false,
      hasVoices: false,
      voicesDetected: false,
      isReading: false,
      isPaused: false,
      currentUtterance: null,
      currentIndex: 0,
      originalTexts: [],
      currentSpeed: CONFIG.SPEED_DEFAULT,
      currentText: '',
      lastCharIndex: 0,
      availableVoices: [],
      currentVoice: null,
      repeatCount: CONFIG.REPEAT_DEFAULT,
      currentRepeat: 0,
      isInfiniteLoop: false,
      currentFontSize: CONFIG.FONT_SIZE_DEFAULT,
      currentHomophoneProcessing: null,
      currentSutra: null,
      lastHomophoneType: 'homophone',
      homophoneDictCache: null,
      lastHomophoneDictFetch: 0
    };

    // 工具函數
    const Utils = {
      // 檢測語音合成支持
      checkSpeechSynthesisSupport() {
        if (typeof window.speechSynthesis === 'undefined') return false;
        
        try {
          const voices = window.speechSynthesis.getVoices();
          if (voices.length === 0) return false;
          
          const chineseVoices = voices.filter(voice => 
            voice.lang === 'zh-TW' || voice.lang === 'zh-CN' || voice.lang === 'zh-HK' || 
            voice.lang.startsWith('zh_TW_') || 
            (voice.lang.startsWith('zh') && voice.lang !== 'zh-TW')
          );
          
          return chineseVoices.length > 0;
        } catch (error) {
          console.warn('語音合成檢測失敗:', error);
          return false;
        }
      },

      // 安全地獲取元素
      getElement(id) {
        return document.getElementById(id);
      },

      // 安全地獲取選擇器元素
      querySelector(selector) {
        return document.querySelector(selector);
      },

      // 安全地獲取所有選擇器元素
      querySelectorAll(selector) {
        return document.querySelectorAll(selector);
      },

      // 防抖函數
      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },

      // 節流函數
      throttle(func, limit) {
        let inThrottle;
        return function() {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      },

      // 顯示錯誤消息
      showError(message, duration = CONFIG.AUTO_HIDE_DELAY) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: var(--white-transparent);
          border: 2px solid #ff6b6b;
          border-radius: var(--border-radius-large);
          padding: 20px;
          box-shadow: var(--shadow-heavy);
          z-index: 10000;
          max-width: 90%;
          text-align: center;
          font-size: 16px;
          color: var(--text-color);
        `;
        errorDiv.innerHTML = `
          <h3 style="color: #ff6b6b; margin-bottom: 15px;">同音字功能暫時無法使用</h3>
          <p style="margin-bottom: 15px;">${message}</p>
          <div style="display: flex; gap: 10px; justify-content: center;">
            <button onclick="this.parentElement.parentElement.remove()" style="
              background-color: #ff6b6b;
              color: var(--white);
              border: none;
              padding: 10px 20px;
              border-radius: var(--border-radius-small);
              cursor: pointer;
              font-size: 14px;
            ">我知道了</button>
            <button onclick="retryHomophone()" style="
              background-color: #4CAF50;
              color: var(--white);
              border: none;
              padding: 10px 20px;
              border-radius: var(--border-radius-small);
              cursor: pointer;
              font-size: 14px;
            ">重試</button>
          </div>
        `;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
          if (errorDiv.parentElement) {
            errorDiv.remove();
          }
        }, duration);
      },

      // 本地存儲管理
      storage: {
        get(key, defaultValue = null) {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
          } catch (error) {
            console.warn('讀取本地存儲失敗:', error);
            return defaultValue;
          }
        },
        
        set(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
          } catch (error) {
            console.warn('寫入本地存儲失敗:', error);
          }
        }
      }
    };

    // 初始化語音合成引擎
    function initSpeechSynthesis() {
      return new Promise((resolve) => {
        // 首先檢查支持情況
        STATE.isSpeechSynthesisSupported = Utils.checkSpeechSynthesisSupport();
        
        if (!STATE.isSpeechSynthesisSupported) {
  
          STATE.isSpeechSynthesisReady = true;
          resolve();
          return;
        }
        
        // 創建一個空的語音實例來初始化引擎
        const utterance = new SpeechSynthesisUtterance('');
        utterance.lang = 'zh-TW';
        
        utterance.onend = () => {
          STATE.isSpeechSynthesisReady = true;
          resolve();
        };
        
        utterance.onerror = (event) => {
  
          STATE.isSpeechSynthesisReady = true;
          resolve();
        };
        
        try {
          window.speechSynthesis.speak(utterance);
        } catch (error) {
  
          STATE.isSpeechSynthesisReady = true;
          resolve();
        }
      });
    }

    // 添加緩存機制
    let homophoneDictCache = {};
    let lastHomophoneDictFetch = 0;
    const CACHE_DURATION = 5 * 60 * 1000; // 5分鐘緩存

    // 清除同音字緩存
    function clearHomophoneCache() {
      homophoneDictCache = {};
      lastHomophoneDictFetch = 0;
    }

    // 添加一個變量來追踪當前的同音字處理和當前經文
    let currentHomophoneProcessing = null;
    let currentSutra = null;
    // 添加變量來追踪用戶的最後同音字顯示選擇
    let lastHomophoneType = 'none'; // 預設為隱藏同音字

    // 修改切換同音字顯示的函數 - 按需載入同音字字典
    async function toggleHomophone() {
      try {
        // 獲取當前經文和章節信息
        const currentSutra = document.getElementById('sutraSelect').value;
        const currentChapter = document.getElementById('chapterSelect');
        
        // 安全地獲取章節標題
        let chapterTitle = '';
        if (currentChapter && currentChapter.selectedIndex >= 0 && currentChapter.options[currentChapter.selectedIndex]) {
          chapterTitle = currentChapter.options[currentChapter.selectedIndex].text;
        }
        
        // 首次使用同音字功能時才載入字典
        console.log('開始載入同音字字典...');
        
        // 如果沒有選擇品名，但有選擇經文，則使用經文名稱作為品名
        if (!chapterTitle && currentSutra) {
          chapterTitle = currentSutra;
        }

        // 一次性獲取完整的同音字字典結構
        const homophoneDict = await getFullHomophoneDict();
        const dictKeys = Object.keys(homophoneDict);
        const formattedKeys = dictKeys.map(key => key === '' ? '全域' : key);

        // 處理當前品名的所有經文（不只是可見的）
        let allTextElements;
        if (chapterTitle === currentSutra) {
          // 使用經文名稱作為品名，只處理當前經文內容區域內的元素
          const contentDiv = document.getElementById('content-' + currentSutra);
          allTextElements = Array.from(contentDiv.querySelectorAll('.original-text'));
        } else {
          // 使用具體品名，處理所有經文元素
          allTextElements = Array.from(document.querySelectorAll('.original-text'));
        }

        const currentChapterTextElements = allTextElements.filter(element => {
            // 檢查是否屬於當前品名
            const parentLine = element.closest('.sutra-line');
            let elementChapterTitle = '';
            
            if (parentLine) {
              // 向上查找最近的品名標題
              let currentElement = parentLine;
              while (currentElement && !elementChapterTitle) {
                // 先檢查前一個兄弟元素
                const prevSibling = currentElement.previousElementSibling;
                if (prevSibling && prevSibling.classList.contains('chapter-title')) {
                  elementChapterTitle = prevSibling.textContent;
                  break;
                }
                
                // 如果前一個兄弟元素不是品名標題，檢查當前元素的子元素
                const chapterTitleChild = currentElement.querySelector('.chapter-title');
                if (chapterTitleChild) {
                  elementChapterTitle = chapterTitleChild.textContent;
                  break;
                }
                
                // 如果都沒有找到，繼續向上查找
                currentElement = currentElement.parentElement;
              }
            }
            
            // 如果使用經文名稱作為品名，則處理該經文的所有內容
            let belongsToCurrentChapter = false;
            if (!chapterTitle) {
              belongsToCurrentChapter = false; // 沒有品名，不處理任何內容
            } else if (chapterTitle === currentSutra) {
              // 使用經文名稱作為品名，處理該經文的所有內容（已經通過範圍限制）
              belongsToCurrentChapter = true;
            } else {
              // 使用具體品名，只處理該品名的內容
              belongsToCurrentChapter = elementChapterTitle === chapterTitle;
            }
            
            return belongsToCurrentChapter;
          });

        // 檢查頁面結構
        const contentDiv = document.getElementById('content-' + currentSutra);
        const chapters = contentDiv.querySelectorAll('.chapter-content');
        
        let processedCount = 0;
        let homophoneAddedCount = 0;
        
        for (let i = 0; i < currentChapterTextElements.length; i++) {
          const textElement = currentChapterTextElements[i];
          if (textElement.textContent) {
            // 從父元素中提取行號（使用伺服器端設定的行號）
            const parentLine = textElement.closest('.sutra-line');
            let lineNumber = '';
            if (parentLine && parentLine.dataset.lineNumber) {
              lineNumber = parentLine.dataset.lineNumber;
            }
            
            // 根據行號從字典中獲取對應的同音字
            let lineHomophoneDict = {};

            
            // 獲取所有層級的同音字字典，用於每個漢字的優先級判斷
            const lineSpecificDict = lineNumber && homophoneDict[chapterTitle] && homophoneDict[chapterTitle][lineNumber] 
              ? homophoneDict[chapterTitle][lineNumber] : {};
            const chapterDefaultDict = homophoneDict[chapterTitle] && homophoneDict[chapterTitle][''] 
              ? homophoneDict[chapterTitle][''] : {};
            const globalDict = homophoneDict[''] && homophoneDict[''][''] 
              ? homophoneDict[''][''] : {};

            
            // 保存原始文本（如果還沒有保存）
            if (!textElement.dataset.original) {
              // 保存原始文本時保留換行符
              textElement.dataset.original = textElement.innerHTML.replace(/<br\s*\/?>/g, '\n');
            }
            
            // 使用純文本進行處理（移除 HTML 標籤）
            const originalText = textElement.dataset.original.replace(/<[^>]*>/g, '');
            
            const result = await addHomophoneWithPriority(originalText, lineSpecificDict, chapterDefaultDict, globalDict);
            
            // 檢查是否有同音字替換（通過檢查是否包含 homophone-text 類）
            const hasHomophoneReplacement = result.includes('homophone-text');
            
            if (hasHomophoneReplacement) {
              // 將換行符轉換回 HTML 的 <br> 標籤
              const finalHtml = result.replace(/\n/g, '<br>');
              textElement.innerHTML = finalHtml;
              homophoneAddedCount++;
            }
            
            processedCount++;
          }
        }
        
      } catch (error) {
        console.error('處理同音字時發生錯誤:', error);
        
        let errorMessage = '處理同音字時發生錯誤，請稍後重試';
        
        if (error.message) {
          if (error.message.includes('google.script.run')) {
            errorMessage = '無法連接到同音字服務，請檢查網路連接或稍後重試';
          } else if (error.message.includes('timeout')) {
            errorMessage = '同音字服務響應超時，請稍後重試';
          } else {
            errorMessage = `錯誤詳情: ${error.message}`;
          }
        }
        
        Utils.showError(errorMessage);
      }
    }

    // 修改按鈕點擊事件 - 使用事件委託避免重複綁定
    document.addEventListener('click', async function(event) {
      if (event.target.classList.contains('homophone-toggle')) {
        const type = event.target.getAttribute('data-type');
        
        // 防止重複點擊
        if (event.target.disabled) {
          return;
        }
        
        // 暫時禁用按鈕
        event.target.disabled = true;
        
        try {
          // 檢查當前同音字顯示狀態 - 通過檢查是否有原始文本來判斷
          const hasOriginalText = document.querySelector('.original-text[data-original]') !== null;
          
          if (type === 'homophone') {
            if (hasOriginalText) {
              // 當前已顯示同音字，再次點擊「顯示同音字」按鈕，不做任何動作
              return;
            } else {
              // 當前已隱藏同音字，切換到顯示
              
              // 先移除所有按鈕的 active 類
              document.querySelectorAll('.homophone-toggle').forEach(btn => {
                btn.classList.remove('active');
              });
              
              // 設置顯示按鈕為 active
              event.target.classList.add('active');
              
              await toggleHomophone();
              lastHomophoneType = 'homophone';
            }
          } else if (type === 'none') {
            if (hasOriginalText) {
              // 當前已顯示同音字，切換到隱藏
              
              // 執行隱藏操作
              const currentChapter = document.getElementById('chapterSelect');
              let chapterTitle = '';
              if (currentChapter && currentChapter.selectedIndex >= 0 && currentChapter.options[currentChapter.selectedIndex]) {
                chapterTitle = currentChapter.options[currentChapter.selectedIndex].text;
              }
              
              let processedCount = 0;
              document.querySelectorAll('.original-text').forEach(textElement => {
                // 檢查是否屬於當前品名
                const parentLine = textElement.closest('.sutra-line');
                let elementChapterTitle = '';
                
                if (parentLine) {
                  // 向上查找最近的品名標題
                  let currentElement = parentLine;
                  while (currentElement && !elementChapterTitle) {
                    // 先檢查前一個兄弟元素
                    const prevSibling = currentElement.previousElementSibling;
                    if (prevSibling && prevSibling.classList.contains('chapter-title')) {
                      elementChapterTitle = prevSibling.textContent;
                      break;
                    }
                    
                    // 如果前一個兄弟元素不是品名標題，檢查當前元素的子元素
                    const chapterTitleChild = currentElement.querySelector('.chapter-title');
                    if (chapterTitleChild) {
                      elementChapterTitle = chapterTitleChild.textContent;
                      break;
                    }
                    
                    // 如果都沒有找到，繼續向上查找
                    currentElement = currentElement.parentElement;
                  }
                }
                
                const belongsToCurrentChapter = !chapterTitle || elementChapterTitle === chapterTitle;
                
                if (belongsToCurrentChapter && textElement.dataset.original) {
                  textElement.innerHTML = textElement.dataset.original;
                  delete textElement.dataset.original;
                  processedCount++;
                }
              });
              
              // 移除所有按鈕的 active 類
              document.querySelectorAll('.homophone-toggle').forEach(btn => {
                btn.classList.remove('active');
              });
              
              // 設置隱藏按鈕為 active
              event.target.classList.add('active');
              lastHomophoneType = 'none';
            } else {
              // 當前已隱藏同音字，再次點擊「隱藏同音字」按鈕，不做任何動作
              return;
            }
          }
        } finally {
          // 重新啟用按鈕
          setTimeout(() => {
            event.target.disabled = false;
          }, 100);
        }
      }
    });



    // 優化切換經文（動態載入）
    async function changeSutra(sheetName, preserveChapterSelection = false) {
      if (!sheetName) return;
      
      // 取消之前的處理
      currentHomophoneProcessing = null;
      currentSutra = sheetName;

      // 顯示載入中提示
      const contentDiv = document.getElementById('content');
      
      // 清理舊的內容容器
      const oldContainers = contentDiv.querySelectorAll('[id^="content-"]');
      oldContainers.forEach(container => container.remove());
      
      contentDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;"><p>正在載入經文內容...</p></div>';
      
      try {
        // 載入工作表數據
        const sheetData = await loadSheetData(sheetName);
        
        // 生成內容 HTML
        const contentHtml = generateSutraContent(sheetName, sheetData);
        
        // 清空內容區域
        contentDiv.innerHTML = '';
        
        // 創建內容容器
        const contentContainer = document.createElement('div');
        contentContainer.id = 'content-' + sheetName;
        contentContainer.style.display = 'block';
        contentContainer.innerHTML = contentHtml;
        contentDiv.appendChild(contentContainer);
        
        // 更新品名選擇器
        const chapterSelect = document.getElementById('chapterSelect');
        const currentChapterValue = preserveChapterSelection ? chapterSelect.value : '';
        
        // 清空選擇器以避免重複添加（在 preserveChapterSelection 時也需要清空，因為會重新添加）
        chapterSelect.innerHTML = '<option value="">請選擇品名</option>';
        
        // 獲取該經文的所有品名
        const chapters = contentContainer.querySelectorAll('.chapter-content');
        
        // 如果只有一個品名，隱藏品名選擇器並自動顯示內容
        if (chapters.length <= 1) {
          chapterSelect.style.display = 'none';
          // 添加品名選項但不顯示內容
          if (chapters.length > 0) {
            const chapterTitle = chapters[0].querySelector('.chapter-title').textContent;
            const option = document.createElement('option');
            option.value = '0';
            option.textContent = chapterTitle;
            chapterSelect.appendChild(option);
            // 只有一個品名時自動顯示內容
            chapters[0].classList.add('active');
            chapterSelect.value = '0';
          }
        } else {
          // 如果有多個品名，顯示品名選擇器
          chapterSelect.style.display = 'block';
          chapters.forEach((chapter, index) => {
            const chapterTitle = chapter.querySelector('.chapter-title').textContent;
            const option = document.createElement('option');
            option.value = index;
            option.textContent = chapterTitle;
            chapterSelect.appendChild(option);
          });
          
          // 如果保持選擇且當前值有效，則恢復選擇
          if (preserveChapterSelection && currentChapterValue !== '' && currentChapterValue !== '請選擇品名') {
            chapterSelect.value = currentChapterValue;
            // 顯示對應的品名內容
            const selectedChapter = chapters[currentChapterValue];
            if (selectedChapter) {
              selectedChapter.classList.add('active');
            }
          } else {
            // 多個品名時不自動選擇，保持「請選擇品名」狀態
            // 用戶需要主動選擇品名才會顯示內容
            
            // 添加提示內容
            const promptDiv = document.createElement('div');
            promptDiv.className = 'chapter-prompt';
            promptDiv.style.cssText = 'text-align: center; padding: 50px; color: #666; font-size: 1.1em;';
            promptDiv.innerHTML = '<p>請從上方下拉選單選擇要閱讀的品名</p>';
            contentContainer.appendChild(promptDiv);
          }
        }
        
        // 重置所有經文的同音字按鈕狀態和數據
        document.querySelectorAll('.homophone-toggle').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // 清除所有經文的同音字數據
        document.querySelectorAll('.original-text').forEach(text => {
          if (text.dataset.original) {
            text.innerHTML = text.dataset.original;
            delete text.dataset.original;
          } else {
            // 如果沒有原始文本，使用 DOM 操作移除所有同音字標記
            const homophoneContainers = text.querySelectorAll('.homophone-container');
            homophoneContainers.forEach(container => {
              // 獲取容器中的漢字（第一個子節點應該是文本節點）
              let charText = '';
              if (container.firstChild && container.firstChild.nodeType === Node.TEXT_NODE) {
                charText = container.firstChild.textContent;
              } else {
                // 如果沒有文本節點，使用整個容器的文本內容
                charText = container.textContent;
              }
              // 創建新的文本節點替換容器
              const textNode = document.createTextNode(charText);
              container.parentNode.replaceChild(textNode, container);
            });
          }
        });

        // 根據用戶的最後選擇設置同音字按鈕狀態
        if (lastHomophoneType === 'homophone') {
          const homophoneButton = contentContainer.querySelector('.homophone-toggle[data-type="homophone"]');
          if (homophoneButton) {
            homophoneButton.classList.add('active');
            // 如果用戶之前選擇了顯示同音字，切換經文後自動顯示新經文的同音字
            setTimeout(() => {
              toggleHomophone();
            }, 100);
          }
        } else {
          // 默認設置為隱藏同音字
          const noneButton = contentContainer.querySelector('.homophone-toggle[data-type="none"]');
          if (noneButton) {
            noneButton.classList.add('active');
          }
          lastHomophoneType = 'none';
        }

                // 平滑滾動到頂部
        window.scrollTo({
          top: 0,
          behavior: 'smooth'
        });
      } catch (error) {
        console.error('載入經文內容失敗:', error);
        contentDiv.innerHTML = '<div style="text-align: center; padding: 50px; color: #666;"><p>載入經文內容失敗，請重試</p></div>';
      }
    }

    // 處理品名選擇事件
    function handleChapterChange(chapterIndex) {
      changeChapter(chapterIndex).catch(error => {
        console.error('切換品名失敗:', error);
      });
    }

    // 切換品名
    async function changeChapter(chapterIndex) {
      // 取消之前的同音字處理
      if (currentHomophoneProcessing) {
        currentHomophoneProcessing = null;
      }
      
      const currentSutra = document.getElementById('sutraSelect').value;
      
      // 如果還沒有載入完整數據，先載入
      const contentContainer = document.getElementById(`content-${currentSutra}`);
      if (!contentContainer || contentContainer.children.length === 0) {
        console.log('品名內容尚未載入，開始載入完整經文數據...');
        // 保存當前選擇的品名索引
        const currentChapterIndex = chapterIndex;
        await changeSutra(currentSutra, true); // 保持品名選擇
      }
      
      const chapters = document.querySelectorAll(`#content-${currentSutra} .chapter-content`);
      
      // 隱藏所有品目內容
      chapters.forEach(chapter => {
        if (chapter && chapter.classList) {
          chapter.classList.remove('active');
        }
      });
      
      // 移除提示內容
      const promptDiv = document.querySelector(`#content-${currentSutra} .chapter-prompt`);
      if (promptDiv) {
        promptDiv.remove();
      }
      
      // 顯示選定的品目內容
      if (chapterIndex !== '') {
        const selectedChapter = chapters[chapterIndex];
        if (selectedChapter && selectedChapter.classList) {
          selectedChapter.classList.add('active');
        }
        
        // 重置所有經文的同音字按鈕狀態和數據
        document.querySelectorAll('.homophone-toggle').forEach(btn => {
          btn.classList.remove('active');
        });
        
        // 清除當前品名的同音字數據
        const currentChapter = document.getElementById('chapterSelect');
        let chapterTitle = '';
        if (currentChapter && currentChapter.selectedIndex >= 0 && currentChapter.options[currentChapter.selectedIndex]) {
          chapterTitle = currentChapter.options[currentChapter.selectedIndex].text;
        }
        
        document.querySelectorAll('.original-text').forEach(text => {
          // 檢查是否屬於當前品名
          const parentLine = text.closest('.sutra-line');
          const chapterTitleElement = parentLine ? parentLine.previousElementSibling : null;
          const elementChapterTitle = chapterTitleElement && chapterTitleElement.classList.contains('chapter-title') 
            ? chapterTitleElement.textContent 
            : '';
          
          const belongsToCurrentChapter = !chapterTitle || elementChapterTitle === chapterTitle;
          
          if (belongsToCurrentChapter) {
            if (text.dataset.original) {
              text.innerHTML = text.dataset.original;
              delete text.dataset.original;
            } else {
              // 如果沒有原始文本，使用 DOM 操作移除所有同音字標記
              const homophoneContainers = text.querySelectorAll('.homophone-container');
              homophoneContainers.forEach(container => {
                // 獲取容器中的漢字（第一個子節點應該是文本節點）
                let charText = '';
                if (container.firstChild && container.firstChild.nodeType === Node.TEXT_NODE) {
                  charText = container.firstChild.textContent;
                } else {
                  // 如果沒有文本節點，使用整個容器的文本內容
                  charText = container.textContent;
                }
                // 創建新的文本節點替換容器
                const textNode = document.createTextNode(charText);
                container.parentNode.replaceChild(textNode, container);
              });
            }
          }
        });
        
        // 根據用戶的最後選擇設置同音字按鈕狀態
        const content = document.getElementById(`content-${currentSutra}`);
        if (lastHomophoneType === 'homophone') {
          const homophoneButton = content.querySelector('.homophone-toggle[data-type="homophone"]');
          if (homophoneButton) {
            homophoneButton.classList.add('active');
            // 如果用戶之前選擇了顯示同音字，切換品名後自動顯示新品名的同音字
            setTimeout(() => {
              toggleHomophone();
            }, 100);
          }
        } else {
          // 默認設置為隱藏同音字
          const noneButton = content.querySelector('.homophone-toggle[data-type="none"]');
          if (noneButton) {
            noneButton.classList.add('active');
          }
          lastHomophoneType = 'none';
        }
        
        // 移除之前的選中狀態
        document.querySelectorAll('.sutra-line.selected').forEach(line => {
          line.classList.remove('selected');
        });
        
        // 重新綁定點擊事件
        const activeChapter = selectedChapter;
        activeChapter.querySelectorAll('.sutra-line').forEach((line) => {
          line.addEventListener('click', function() {
            const lines = activeChapter.querySelectorAll('.sutra-line');
            const index = Array.from(lines).indexOf(this);
            setSelectedSentence(index);
          });
        });
      }
      
      // 滾動到頂部
      window.scrollTo(0, 0);
    }

    // 設置當前選中的句子
    function setSelectedSentence(index) {
      // 獲取當前選擇的經文和品目
      const currentSutra = document.getElementById('sutraSelect').value;
      const currentChapter = document.getElementById('chapterSelect');
      
      // 安全地獲取品目值
      let currentChapterValue = '';
      if (currentChapter && currentChapter.selectedIndex >= 0 && currentChapter.options[currentChapter.selectedIndex]) {
        currentChapterValue = currentChapter.value;
      }
      
      const contentDiv = document.getElementById('content-' + currentSutra);
      const activeChapter = contentDiv.querySelector('.chapter-content.active');
      
      if (!activeChapter) return;
      
      // 移除之前的選中狀態
      document.querySelectorAll('.sutra-line.selected').forEach(line => {
        line.classList.remove('selected');
      });
      
      // 添加新的選中狀態
      const lines = activeChapter.querySelectorAll('.sutra-line');
      if (lines[index]) {
        lines[index].classList.add('selected');
        lines[index].scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // 切換翻譯顯示
    function toggleTranslation(element) {
      // 檢查元素是否有翻譯功能
      if (!element.classList.contains('has-translation')) {
        return;
      }
      
      const translation = element.nextElementSibling;
      const sutraLine = element.closest('.sutra-line');
      
      if (!translation || !translation.classList.contains('translation')) {
        return;
      }
      
      // 檢查是否有實際內容
      const translationText = translation.getAttribute('data-translation');
      
      if (!translationText || translationText.trim() === '') {
        return;
      }
      
      if (translation.classList.contains('show')) {
        // 隱藏翻譯
        translation.classList.remove('show');
        translation.style.display = 'none';
        
        // 移除懸停效果
        if (sutraLine) {
          sutraLine.classList.remove('translation-active');
        }
      } else {
        // 顯示翻譯
        translation.classList.add('show');
        translation.style.display = 'block';
        translation.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // 添加懸停效果
        if (sutraLine) {
          sutraLine.classList.add('translation-active');
        }
        
        // 選中當前經文行
        selectSutraLine(element);
      }
    }

    // 回到頂部按鈕 - 使用節流優化性能
    window.onscroll = Utils.throttle(function() {
      const backToTop = Utils.querySelector('.back-to-top');
      if (!backToTop) return;
      
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      backToTop.style.display = scrollTop > 20 ? 'block' : 'none';
    }, 100);
    
    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }
    
    // 字體大小管理
    const FontManager = {
      updateFontSize(value) {
        const numericValue = Math.max(CONFIG.FONT_SIZE_MIN, Math.min(CONFIG.FONT_SIZE_MAX, parseInt(value)));
        STATE.currentFontSize = numericValue;
        
        document.body.style.fontSize = numericValue + 'px';
        
        // 確保播放界面的字體大小保持固定
        const readingPanel = Utils.querySelector('.reading-control-panel');
        if (readingPanel) {
          readingPanel.style.fontSize = window.innerWidth <= 768 ? '17px' : '18px';
        }
        
        this.updateButtons();
        Utils.storage.set('preferredFontSize', numericValue);
      },

      increaseFontSize() {
        const newSize = Math.min(STATE.currentFontSize + 2, CONFIG.FONT_SIZE_MAX);
        this.updateFontSize(newSize);
      },

      decreaseFontSize() {
        const newSize = Math.max(STATE.currentFontSize - 2, CONFIG.FONT_SIZE_MIN);
        this.updateFontSize(newSize);
      },

      updateButtons() {
        const decreaseBtn = Utils.querySelector('.font-size-btn[onclick="decreaseFontSize()"]');
        const increaseBtn = Utils.querySelector('.font-size-btn[onclick="increaseFontSize()"]');
        
        if (decreaseBtn) {
          decreaseBtn.disabled = STATE.currentFontSize <= CONFIG.FONT_SIZE_MIN;
        }
        
        if (increaseBtn) {
          increaseBtn.disabled = STATE.currentFontSize >= CONFIG.FONT_SIZE_MAX;
        }
      }
    };

    // 增加字體大小
    function increaseFontSize() {
      FontManager.increaseFontSize();
    }

    // 減少字體大小
    function decreaseFontSize() {
      FontManager.decreaseFontSize();
    }
    
    // 動態載入相關函數
    let loadedSheets = new Set(); // 記錄已載入的工作表
    let sheetDataCache = {}; // 緩存工作表數據

    // 載入工作表名稱列表
    async function loadSheetNames() {
      try {
        console.log('loadSheetNames 開始執行');
        console.log('當前 sheetNames 變數:', typeof sheetNames !== 'undefined' ? sheetNames : '未定義');
        
        // 首先檢查是否有預載入的工作表名稱
        if (typeof sheetNames !== 'undefined' && sheetNames && sheetNames.length > 0) {
          console.log('使用預載入的工作表名稱:', sheetNames);
          return sheetNames;
        }
        
        console.log('從 API 載入工作表名稱');
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(sheetNames => {
              console.log('從 API 獲得工作表名稱:', sheetNames);
              resolve(sheetNames || []);
            })
            .withFailureHandler(error => {
              console.error('載入工作表名稱失敗:', error);
              resolve([]);
            })
            .getAllSheetNames();
        });
      } catch (error) {
        console.error('載入工作表名稱錯誤:', error);
        return [];
      }
    }

    // 輕量級載入品名選項（僅載入標題行）
    async function loadChapterOptions(sheetName) {
      try {
        console.log(`開始載入工作表標題行: ${sheetName}`);
        
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(headerData => {
              console.log(`成功載入工作表標題行: ${sheetName}`);
              
              // 生成品名選項但不顯示內容
              const chapterSelect = document.getElementById('chapterSelect');
              chapterSelect.innerHTML = '<option value="">請選擇品名</option>';
              
              // 解析標題行獲取品名
              if (headerData && headerData.length > 0) {
                const headers = headerData[0];
                let chapterCount = 0;
                
                // 遍歷奇數欄位（品名欄位）
                for (let col = 0; col < headers.length; col += 2) {
                  if (headers[col] && headers[col].toString().trim()) {
                    const chapterTitle = headers[col].toString().trim();
                    const option = document.createElement('option');
                    option.value = chapterCount;
                    option.textContent = chapterTitle;
                    chapterSelect.appendChild(option);
                    chapterCount++;
                  }
                }
                
                // 根據品名數量決定是否顯示選擇器
                if (chapterCount <= 1) {
                  chapterSelect.style.display = 'none';
                  if (chapterCount === 1) {
                    // 只有一個品名時，自動載入完整數據
                    setTimeout(() => changeSutra(sheetName), 100);
                  }
                } else {
                  chapterSelect.style.display = 'block';
                  // 多個品名時顯示提示
                  const contentDiv = document.getElementById('content');
                  contentDiv.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #666; font-size: 1.1em;">
                      <p>請從上方下拉選單選擇要閱讀的品名</p>
                    </div>
                  `;
                }
              }
              
              resolve(headerData);
            })
            .withFailureHandler(error => {
              console.error(`載入工作表 ${sheetName} 標題行失敗:`, error);
              reject(error);
            })
            .loadSheetHeaders(sheetName);
        });
      } catch (error) {
        console.error(`載入工作表 ${sheetName} 標題行錯誤:`, error);
        throw error;
      }
    }

    // 載入特定工作表的數據
    async function loadSheetData(sheetName) {
      try {
        // 檢查緩存
        if (sheetDataCache[sheetName]) {
          return sheetDataCache[sheetName];
        }

        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(data => {
              // 緩存數據
              sheetDataCache[sheetName] = data || [];
              loadedSheets.add(sheetName);
              resolve(data || []);
            })
            .withFailureHandler(error => {
              console.error(`載入工作表 ${sheetName} 數據失敗:`, error);
              resolve([]);
            })
            .loadSheetData(sheetName);
        });
      } catch (error) {
        console.error(`載入工作表 ${sheetName} 數據錯誤:`, error);
        return [];
      }
    }

    // 生成經文內容 HTML
    function generateSutraContent(sheetName, sheetData) {
      if (!sheetData || sheetData.length === 0) {
        return '<div style="text-align: center; padding: 50px; color: #666;">該經文暫無數據</div>';
      }

      let html = `
        <div class="homophone-controls">
          <button class="homophone-toggle" data-type="none">隱藏同音字</button>
          <button class="homophone-toggle" data-type="homophone">顯示同音字</button>
        </div>
      `;

      // 遍歷所有列，每兩列為一組（原文和翻譯）
      for (let col = 0; col < sheetData[0].length; col += 2) {
        if (sheetData[0][col]) { // 如果有品名
          // 找出這個品名最後一行的索引
          let lastRowIndex = sheetData.length - 1;
          while (lastRowIndex > 0 && (!sheetData[lastRowIndex][col] || String(sheetData[lastRowIndex][col]).trim() === '')) {
            lastRowIndex--;
          }
          
          // 檢查是否為白話文章節
          const isTranslationChapter = sheetData[0][col + 1] && String(sheetData[0][col + 1]).indexOf('白話文') !== -1;
          
          html += `<div id="chapter-${sheetName}-${col}" class="chapter-content">`;
          html += `<h2 class="chapter-title">${sheetData[0][col]}</h2>`;
          
          for (let i = 1; i <= lastRowIndex; i++) {
            const originalText = String(sheetData[i][col] || '').replace(/^\s*\n/, '').trim();
            const translationText = String(sheetData[i][col + 1] || '').replace(/^\s*\n/, '');
            
            // 檢查是否有翻譯
            const hasTranslation = isTranslationChapter && translationText.replace(/\n/g, '').trim() !== '';
            
            // 根據是否有翻譯添加不同的CSS類
            const sutraLineClass = hasTranslation ? 'sutra-line has-translation' : 'sutra-line no-translation';
            const originalTextClass = hasTranslation ? 'original-text has-translation' : 'original-text no-translation';
            
            // 計算顯示的行號：標題行顯示為第1行，內容行從第2行開始
            const displayRowNumber = i === 1 ? 1 : i;
            
            html += `<div class="${sutraLineClass}" data-line-number="${i}">`;
            
            // 添加書籤按鈕（手機版）
            html += `<button class="bookmark-btn" onclick="toggleBookmark(this)" title="點擊添加/刪除書籤" aria-label="書籤">
              <i class="fas fa-bookmark"></i>
            </button>`;
            
            if (hasTranslation) {
              html += `<div class="${originalTextClass}" onclick="toggleTranslation(this)" onmousedown="selectSutraLine(this)" data-sheet-row="${displayRowNumber}">${originalText}</div>`;
              const cleanTranslation = translationText.replace(/\n/g, '').trim();
              html += `<div class="translation" style="display: none;" data-translation="${cleanTranslation}">${cleanTranslation}</div>`;
            } else {
              html += `<div class="${originalTextClass}" onmousedown="selectSutraLine(this)" data-sheet-row="${displayRowNumber}">${originalText}</div>`;
            }
            
            html += '</div>';
          }
          
          html += '</div>';
        }
      }

      return html;
    }

    // 初始化經文選擇器
    async function initializeSutraSelector() {
      try {

        
        const sheetNames = await loadSheetNames();
        
        
        const sutraSelect = document.getElementById('sutraSelect');
        if (!sutraSelect) {
          console.error('找不到經文選擇器元素');
          return;
        }
        
        // 清空現有選項
        sutraSelect.innerHTML = '';
        
        if (!sheetNames || sheetNames.length === 0) {

          sutraSelect.innerHTML = '<option value="">無可用經文</option>';
          return;
        }
        
        
        
        // 添加選項
                  sheetNames.forEach((sheetName, index) => {
            const option = document.createElement('option');
            option.value = sheetName;
            option.textContent = sheetName;
            sutraSelect.appendChild(option);
          });
        
                  // 選擇第一個經文並載入標題行以顯示品名選單
          if (sheetNames.length > 0) {
            sutraSelect.value = sheetNames[0];
            // 只載入第一個經文的標題行以生成品名下拉選單（輕量級載入）
            await loadChapterOptions(sheetNames[0]);
          }
        
        
      } catch (error) {
        console.error('初始化經文選擇器失敗:', error);
        const sutraSelect = document.getElementById('sutraSelect');
        if (sutraSelect) {
          sutraSelect.innerHTML = '<option value="">載入失敗</option>';
        }
      }
    }

    // 靜默載入同音字字典（僅用於預載）
    async function silentLoadHomophoneDict() {
      try {
        const dict = await getFullHomophoneDict();
        return dict;
      } catch (error) {
        console.warn('同音字字典預載失敗:', error);
        return {};
      }
    }

    // 頁面加載時恢復用戶的字體大小設置
    window.onload = async function() {
      try {
        // 檢查瀏覽器兼容性
        const isCompatible = checkBrowserCompatibility();
        

        
        const savedSize = Utils.storage.get('preferredFontSize', CONFIG.FONT_SIZE_DEFAULT);
        
        FontManager.updateFontSize(savedSize);
        
        // 初始化語速按鈕狀態
        updateSpeedButtons();
        
        // 清除同音字緩存，確保顯示最新數據
        clearHomophoneCache();
        
        // 初始化經文選擇器（動態載入）
        await initializeSutraSelector();

        // 移除同音字字典預載入，改為真正的按需載入
        // 同音字字典將在用戶首次使用同音字功能時才載入

        // 初始化語音合成
        try {
          await initSpeechSynthesis();
        } catch (error) {
          console.warn('語音合成初始化失敗:', error);
        }
        
        // 初始化語音列表
        try {
          initVoices();
        } catch (error) {
          console.warn('語音列表初始化失敗:', error);
        }
      
                    // 監聽語音列表變化（特別重要，因為某些瀏覽器需要時間加載語音）
      if (window.speechSynthesis) {
        window.speechSynthesis.onvoiceschanged = function() {
  
          // 重新檢查語音合成支持狀態
          STATE.isSpeechSynthesisSupported = Utils.checkSpeechSynthesisSupport();
          initVoices();
        };
        
        // 簡化的延遲檢查 - 只在必要時進行
        setTimeout(() => {
          // 如果已經檢測到語音，停止檢測
          if (STATE.voicesDetected) {
            return;
          }
          
          const voices = window.speechSynthesis.getVoices();
          if (voices.length === 0) {
            // 如果仍然沒有語音，再等一次
            setTimeout(() => {
              // 如果已經檢測到語音，停止檢測
              if (STATE.voicesDetected) {
                return;
              }
      
              STATE.isSpeechSynthesisSupported = Utils.checkSpeechSynthesisSupport();
              initVoices();
            }, 2000);
          } else {
            // 如果已經有語音，直接更新
            STATE.isSpeechSynthesisSupported = Utils.checkSpeechSynthesisSupport();
            initVoices();
          }
        }, 1000);
      }
      
      // 最終檢查語音功能狀態
      setTimeout(() => {
        // 如果已經檢測到語音，跳過最終檢查
        if (STATE.voicesDetected) {
          return;
        }
        
        const voices = window.speechSynthesis.getVoices();
                  if (voices.length > 0) {
            STATE.isSpeechSynthesisSupported = true;
          }
        }, 3000);
      } catch (error) {
        console.error('頁面初始化失敗:', error);
        // 顯示錯誤提示但不阻止頁面正常顯示
        Utils.showError('部分功能初始化失敗，但頁面仍可正常使用。');
      }
    };

    // 朗讀相關變量已移至 STATE 對象中管理

    // 處理文本，移除多餘的換行符和空格
    function processText(text) {
      const cleanText = text.replace(/^\s+|\s+$/g, '')  // 移除首尾空白
                           .replace(/\n+/g, ' ')       // 將多個換行符替換為空格
                           .replace(/\s+/g, ' ');      // 將多個空格替換為單個空格
      
      // 直接返回清理後的文本，不添加額外的緩衝符號
      return cleanText;
    }

    // 預熱語音引擎的函數
    function warmUpSpeechEngine() {
      return new Promise((resolve) => {
        try {
          // 創建一個短暫的預熱語音，使用一個點號
          const warmUpUtterance = new SpeechSynthesisUtterance('。');
          warmUpUtterance.volume = 0.01;
          warmUpUtterance.rate = 3.0;
          warmUpUtterance.lang = 'zh-TW';
          if (STATE.currentVoice) {
            warmUpUtterance.voice = STATE.currentVoice;
          }
          
          warmUpUtterance.onend = () => {
            setTimeout(resolve, 200); // 預熱後再等待一點時間
          };
          warmUpUtterance.onerror = () => {
            setTimeout(resolve, 200);
          };
          
          window.speechSynthesis.speak(warmUpUtterance);
          
          // 如果沒有觸發事件，也要繼續
          setTimeout(resolve, 500);
        } catch (error) {
          setTimeout(resolve, 200);
        }
      });
    }

    // 安全播放語音的函數
    function safeSpeak(utterance, forceCancel = false) {
      return new Promise((resolve) => {
        try {
          // 統一的播放前準備函數
          const playAfterDelay = (delay = 0) => {
            setTimeout(() => {
              console.log('開始播放語音:', utterance.text.substring(0, 20) + '...');
              window.speechSynthesis.speak(utterance);
              resolve();
            }, delay);
          };

          if (window.speechSynthesis.speaking && forceCancel) {
            console.log('取消當前語音並準備播放新語音');
            window.speechSynthesis.cancel();
            // 強制取消後需要更長的延遲
            playAfterDelay(2800);
          } else if (window.speechSynthesis.speaking) {
            console.log('等待當前語音結束');
            // 等待當前語音結束
            const checkSpeaking = () => {
              if (!window.speechSynthesis.speaking) {
                console.log('當前語音已結束，開始播放新語音');
                // 等待較長時間確保語音引擎完全空閒
                playAfterDelay(2200);
              } else {
                setTimeout(checkSpeaking, 100);
              }
            };
            setTimeout(checkSpeaking, 100);
          } else {
            console.log('直接播放語音');
            // 直接播放，不添加延遲
            playAfterDelay(0);
          }
        } catch (error) {
          console.warn('語音播放錯誤:', error);
          resolve();
        }
      });
    }

    // 設置語音實例的事件監聽
    function setupUtteranceEvents(utterance) {
      let startTime = null;
      let totalDuration = 0;
      let isGoogleVoice = STATE.currentVoice && STATE.currentVoice.name.toLowerCase().includes('google');
      let progressInterval = null;

      // 如果是 Google 語音，使用時間來估算進度
      if (isGoogleVoice) {
        utterance.onstart = () => {
          console.log('語音開始播放 (Google):', utterance.text.substring(0, 30) + '...');
          startTime = Date.now();
          // 估算總時長（基於文字長度和語速）
          totalDuration = (STATE.currentText.length * 100) / STATE.currentSpeed;
        };

        // 使用 setInterval 來模擬進度更新
        progressInterval = setInterval(() => {
          if (!STATE.isReading || STATE.isPaused) {
            clearInterval(progressInterval);
            return;
          }

          const elapsedTime = Date.now() - startTime;
          const progress = Math.min((elapsedTime / totalDuration) * 100, 100);
          const charIndex = Math.floor((progress / 100) * STATE.currentText.length);

          if (progress >= 100) {
            clearInterval(progressInterval);
          }
        }, 100);
      } else {
        // 其他語音引擎使用原有的 onboundary 事件
        utterance.onstart = () => {
          console.log('語音開始播放 (其他):', utterance.text.substring(0, 30) + '...');
        };
        
        utterance.onboundary = (event) => {
          STATE.lastCharIndex = Math.min(event.charIndex, STATE.currentText.length);
        };
      }

      utterance.onend = () => {
        if (progressInterval) {
          clearInterval(progressInterval);
        }
        
        if (STATE.isReading && !STATE.isPaused) {
          STATE.currentIndex++;
          // 確保語音引擎完全結束後再播放下一句，避免播放不完整的句子
          const checkAndContinue = () => {
            // 檢查語音引擎是否真正結束
            if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
              // 如果還在播放，等待更長時間後再檢查
              setTimeout(checkAndContinue, 150);
            } else {
              // 確認完全結束後，再播放下一句
              if (STATE.isReading && !STATE.isPaused) {
                readNext();
              }
            }
          };
          // 初始延遲後開始檢查
          setTimeout(checkAndContinue, 150);
        }
      };

      utterance.onerror = (event) => {
        if (progressInterval) {
          clearInterval(progressInterval);
        }
        
        // 忽略停止時的正常中斷錯誤
        if (event.error === 'interrupted' && !STATE.isReading) {
          return;
        }

        // 忽略點擊切換時的正常中斷錯誤
        if (event.error === 'interrupted' && event.elapsedTime > 0) {
          return;
        }
        
        // 處理中斷錯誤
        if (event.error === 'interrupted' || event.error === 'canceled') {
          if (STATE.isReading && !STATE.isPaused) {
            // 添加延遲後重新開始朗讀
            setTimeout(() => {
              if (STATE.isReading && !STATE.isPaused) {
                // 重新創建語音實例
                const newUtterance = new SpeechSynthesisUtterance(STATE.currentText);
                newUtterance.lang = 'zh-TW';
                newUtterance.rate = STATE.currentSpeed;
                newUtterance.pitch = 1;
                newUtterance.volume = 1;
                if (STATE.currentVoice) {
                  newUtterance.voice = STATE.currentVoice;
                }

                setupUtteranceEvents(newUtterance);
                STATE.currentUtterance = newUtterance;
                
                try {
                  window.speechSynthesis.speak(newUtterance);
                } catch (error) {
                  // 如果重新開始失敗，繼續下一句
                  STATE.currentIndex++;
                  readNext();
                }
              }
            }, 100);
          }
        }
      };
    }

    // 開始朗讀
    async function startReading(startIndex = 0) {
      if (!STATE.isReading) {
        // 檢查語音合成是否支持
        if (!STATE.isSpeechSynthesisSupported) {
          showVoiceNotSupportedMessage();
          return;
        }
        
        // 確保語音合成引擎已初始化
        if (!STATE.isSpeechSynthesisReady) {
          await initSpeechSynthesis();
        }
        
        // 再次檢查支持情況（初始化後可能會有變化）
        if (!STATE.isSpeechSynthesisSupported) {
          showVoiceNotSupportedMessage();
          return;
        }
        
        STATE.isReading = true;
        STATE.isPaused = false;
        STATE.lastCharIndex = 0;
        STATE.currentRepeat = 0; // 重置重複次數
        
        // 獲取當前選擇的經文
        const currentSutra = document.getElementById('sutraSelect').value;
        const contentDiv = document.getElementById('content-' + currentSutra);
        
        // 獲取當前活動的章節
        const activeChapter = contentDiv.querySelector('.chapter-content.active');
        if (!activeChapter) return;

        // 獲取所有需要朗讀的文本
        originalTexts = Array.from(activeChapter.querySelectorAll('.original-text'));
        STATE.currentIndex = startIndex;
        
        // 開始朗讀選定的句子
        readNext();
      }
    }

    // 切換朗讀狀態（播放/暫停）
    async function toggleReading(button) {
      // 檢查語音合成是否支持
      if (!STATE.isSpeechSynthesisSupported) {
        showVoiceNotSupportedMessage();
        return;
      }
      
      if (STATE.isReading) {
        if (STATE.isPaused) {
          // 如果已暫停，則從當前句子的開頭重新播放
          STATE.isPaused = false;
          button.innerHTML = '<i class="fas fa-pause"></i>';
          button.classList.add('active');
          
          // 確保語音合成引擎已初始化
          if (!STATE.isSpeechSynthesisReady) {
            await initSpeechSynthesis();
          }
          
          // 從當前句子的開頭重新播放
          setTimeout(() => {
            if (STATE.isReading && !STATE.isPaused) {
              // 重新創建語音實例，從當前句子開頭播放
              const newUtterance = new SpeechSynthesisUtterance(STATE.currentText);
              newUtterance.lang = 'zh-TW';
              newUtterance.rate = STATE.currentSpeed;
              newUtterance.pitch = 1;
              newUtterance.volume = 1;
              
              if (STATE.currentVoice) {
                newUtterance.voice = STATE.currentVoice;
              }
              
              setupUtteranceEvents(newUtterance);
              STATE.currentUtterance = newUtterance;
              
              safeSpeak(newUtterance, true).catch((error) => {
                setTimeout(() => {
                  if (STATE.isReading && !STATE.isPaused) {
                    readNext();
                  }
                }, 200);
              });
            }
          }, 100);
        } else {
          // 如果正在朗讀，則暫停
          STATE.isPaused = true;
          button.innerHTML = '<i class="fas fa-play"></i>';
          button.classList.remove('active');
          
          try {
            window.speechSynthesis.pause();
          } catch (error) {
          }
        }
      } else {
        // 開始新的朗讀
        // 獲取當前選中的句子索引
        const currentSutra = document.getElementById('sutraSelect').value;
        const contentDiv = document.getElementById('content-' + currentSutra);
        const activeChapter = contentDiv.querySelector('.chapter-content.active');
        
        if (!activeChapter) return;
        
        const selectedLine = activeChapter.querySelector('.sutra-line.selected');
        const startIndex = selectedLine ? 
          Array.from(activeChapter.querySelectorAll('.sutra-line')).indexOf(selectedLine) : 0;
        
        await startReading(startIndex);
        button.innerHTML = '<i class="fas fa-pause"></i>';
        button.classList.add('active');
      }
    }

    // 停止朗讀
    function stopReading() {
      STATE.isReading = false;
      STATE.isPaused = false;
      STATE.lastCharIndex = 0;
      STATE.currentRepeat = 0; // 重置重複次數
      
      try {
        // 確保在開始新的朗讀前取消所有正在進行的朗讀
        window.speechSynthesis.cancel();
        // 添加一個小延遲
        setTimeout(() => {
          STATE.currentUtterance = null;
        }, 100);
      } catch (error) {
      }
      
      // 重置播放按鈕狀態
      const controlPanel = document.querySelector('.reading-control-panel');
      const button = controlPanel.querySelector('.read-button');
      if (button) {
        button.innerHTML = '<i class="fas fa-play"></i>';
        button.classList.remove('active');
      }

      // 移除所有朗讀狀態
      document.querySelectorAll('.sutra-line.reading').forEach(line => {
        line.classList.remove('reading');
      });
    }

    // 朗讀下一段
    function readNext() {
      if (!STATE.isReading || STATE.isPaused) {
        return;
      }

      // 檢查是否已經播放完所有文本
      if (STATE.currentIndex >= originalTexts.length) {
        // 檢查是否需要繼續播放
        if (STATE.isInfiniteLoop || STATE.currentRepeat < STATE.repeatCount - 1) {
          // 重置索引到開始位置
          STATE.currentIndex = 0;
          if (!STATE.isInfiniteLoop) {
            STATE.currentRepeat++;
          }
          
          // 顯示當前播放次數
          if (STATE.isInfiniteLoop) {
    
          } else {
            
          }
          
          // 繼續播放，確保上一句完全結束
          const checkAndRestart = () => {
            // 確保語音引擎完全結束後再重新開始，避免播放不完整的句子
            if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
              // 如果還在播放，等待更長時間後再檢查
              setTimeout(checkAndRestart, 200);
            } else {
              // 確認完全結束後，再開始新一輪播放
              if (STATE.isReading && !STATE.isPaused) {
                readNext();
              }
            }
          };
          // 初始延遲後開始檢查
          setTimeout(checkAndRestart, 500);
          return;
        } else {
          // 播放完成，停止朗讀
          stopReading();
          return;
        }
      }

      STATE.lastCharIndex = 0;
      const textElement = originalTexts[STATE.currentIndex];
      let text = '';

      // 遍歷所有子節點
      textElement.childNodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('homophone-container')) {
          // 取同音字（在 homophone-text 中的文字）
          const homophoneText = node.querySelector('.homophone-text');
          if (homophoneText) {
            text += homophoneText.textContent;
          }
        } else if (node.nodeType === Node.TEXT_NODE) {
          // 取原文
          text += node.textContent;
        }
      });

      // 處理文本並保存
      STATE.currentText = processText(text);
      
      // 調試信息
      console.log('原始文本:', text);
      console.log('處理後文本:', STATE.currentText);
      console.log('文本長度:', STATE.currentText.length);

      STATE.currentUtterance = new SpeechSynthesisUtterance(STATE.currentText);
      STATE.currentUtterance.lang = 'zh-TW';
      STATE.currentUtterance.rate = STATE.currentSpeed;
      STATE.currentUtterance.pitch = 1;
      STATE.currentUtterance.volume = 1;
      if (STATE.currentVoice) {
        STATE.currentUtterance.voice = STATE.currentVoice;
      }
      
      // 為音頻設備優化設置
      // 這些設置有助於減少音頻延遲和緩衝問題
      try {
        if (STATE.currentUtterance.voice) {
          // 確保使用指定的語音
          STATE.currentUtterance.voice = STATE.currentVoice;
        }
      } catch (error) {
        console.log('音頻設備優化設置失敗，但不影響播放');
      }
      setupUtteranceEvents(STATE.currentUtterance);
      document.querySelectorAll('.sutra-line.reading').forEach(line => {
        line.classList.remove('reading');
      });
      textElement.closest('.sutra-line').classList.add('reading');
      textElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // 在播放前確保語音引擎狀態乾淨，確保不會播放不完整的句子
      const safeStartNext = () => {
        // 再次確認語音引擎完全結束
        if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
          // 如果還在播放，取消並等待
          window.speechSynthesis.cancel();
          setTimeout(safeStartNext, 200);
        } else {
          // 確認完全結束後才開始播放下一句
          safeSpeak(STATE.currentUtterance, false).catch(() => {
            setTimeout(() => {
              if (STATE.isReading && !STATE.isPaused) {
                readNext();
              }
            }, 200);
          });
        }
      };
      
      if (window.speechSynthesis.speaking || window.speechSynthesis.pending) {
        console.log('檢測到語音仍在播放，等待結束...');
        window.speechSynthesis.cancel();
        setTimeout(safeStartNext, 200);
      } else {
        // 前一句已經自然結束，直接播放下一句
        safeStartNext();
      }
    }

    // DOM元素緩存（按需初始化）
    const DOMCache = {
      _speedValue: null,
      _speedButtons: null,
      _repeatInput: null,
      _repeatButton: null,
      
      get speedValue() {
        if (!this._speedValue) {
          this._speedValue = document.querySelector('.speed-value');
        }
        return this._speedValue;
      },
      
      get speedButtons() {
        if (!this._speedButtons) {
          this._speedButtons = {
            decrease: document.querySelector('.speed-button[onclick="decreaseSpeed()"]'),
            increase: document.querySelector('.speed-button[onclick="increaseSpeed()"]')
          };
        }
        return this._speedButtons;
      },
      
      get repeatInput() {
        if (!this._repeatInput) {
          this._repeatInput = document.getElementById('repeatInput');
        }
        return this._repeatInput;
      },
      
      get repeatButton() {
        if (!this._repeatButton) {
          this._repeatButton = document.querySelector('.repeat-infinite-btn');
        }
        return this._repeatButton;
      },
      
      // 清除緩存（當DOM結構變化時使用）
      clear() {
        this._speedValue = null;
        this._speedButtons = null;
        this._repeatInput = null;
        this._repeatButton = null;
      }
    };

    // 更新語速（統一函數）
    function updateSpeedValue(newSpeed) {
      STATE.currentSpeed = newSpeed;
      const speedValueEl = DOMCache.speedValue;
      if (speedValueEl) {
        speedValueEl.textContent = newSpeed.toFixed(1) + 'x';
      }
      
      // 如果正在朗讀，更新當前語速
      if (STATE.isReading && STATE.currentUtterance) {
        STATE.currentUtterance.rate = STATE.currentSpeed;
      }
      
      // 更新按鈕狀態
      updateSpeedButtons();
    }

    // 更新語速
    function updateSpeed(value) {
      updateSpeedValue(parseFloat(value));
    }

    // 增加語速
    function increaseSpeed() {
      const newSpeed = Math.min(STATE.currentSpeed + 0.1, 2.0);
      updateSpeedValue(newSpeed);
    }

    // 減少語速
    function decreaseSpeed() {
      const newSpeed = Math.max(STATE.currentSpeed - 0.1, 0.5);
      updateSpeedValue(newSpeed);
    }

    // 更新語速按鈕狀態
    function updateSpeedButtons() {
      const buttons = DOMCache.speedButtons;
      
      if (buttons.decrease) {
        buttons.decrease.disabled = STATE.currentSpeed <= 0.5;
      }
      
      if (buttons.increase) {
        buttons.increase.disabled = STATE.currentSpeed >= 2.0;
      }
    }

    // 更新播放次數
    function updateRepeatCount(value) {
      const count = parseInt(value);
      const button = DOMCache.repeatButton;
      const input = DOMCache.repeatInput;
      
      // 驗證輸入值
      if (isNaN(count) || count < 1) {
        if (input) input.value = 1;
        STATE.repeatCount = 1;
        STATE.isInfiniteLoop = false;
        if (button) button.classList.remove('active');
        return;
      }
      
      STATE.repeatCount = count;
      STATE.isInfiniteLoop = false;
      if (button) button.classList.remove('active');
      if (input) input.placeholder = '';
      
      // 如果正在朗讀，顯示當前設置
      // 預留未來功能擴展
    }

    // 設置無限循環
    function setInfiniteRepeat() {
      STATE.isInfiniteLoop = true;
      const input = DOMCache.repeatInput;
      const button = DOMCache.repeatButton;
      
      if (input) {
        input.value = '';
        input.placeholder = '∞';
      }
      if (button) {
        button.classList.add('active');
      }
      
      // 如果正在朗讀，顯示當前設置
      // 預留未來功能擴展
    }

    // 驗證播放次數輸入
    function validateRepeatInput(input) {
      const value = parseInt(input.value);
      const button = DOMCache.repeatButton;
      
      if (isNaN(value) || value < 1) {
        input.value = 1;
        STATE.repeatCount = 1;
        STATE.isInfiniteLoop = false;
        input.placeholder = '';
        if (button) button.classList.remove('active');
      } else if (value > 999) {
        input.value = 999;
        STATE.repeatCount = 999;
        STATE.isInfiniteLoop = false;
        input.placeholder = '';
        if (button) button.classList.remove('active');
      } else {
        STATE.repeatCount = value;
        STATE.isInfiniteLoop = false;
        input.placeholder = '';
        if (button) button.classList.remove('active');
      }
    }

    // 選中經文行
    function selectSutraLine(element) {
      // 移除所有其他選中狀態
      document.querySelectorAll('.sutra-line.selected').forEach(line => {
        line.classList.remove('selected');
      });
      
      // 選中當前經文行
      const sutraLine = element.closest('.sutra-line');
      if (sutraLine) {
        sutraLine.classList.add('selected');
      }
    }

    // 顯示語音不支持的消息
    function showVoiceNotSupportedMessage() {
      // 創建或更新提示消息
      let messageDiv = document.getElementById('voice-not-supported-message');
      if (!messageDiv) {
        messageDiv = document.createElement('div');
        messageDiv.id = 'voice-not-supported-message';
        messageDiv.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background-color: rgba(255, 255, 255, 0.95);
          border: 2px solid #8B4513;
          border-radius: 10px;
          padding: 20px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
          z-index: 10000;
          max-width: 90%;
          text-align: center;
          font-size: 16px;
          color: #333;
        `;
        document.body.appendChild(messageDiv);
      }
      
      // 獲取當前檢測到的語音信息
      const voiceInfo = getVoiceStatusInfo();
      
      messageDiv.innerHTML = `
        <h3 style="color: #8B4513; margin-bottom: 15px;">語音功能檢測結果</h3>
        <div style="text-align: left; margin-bottom: 15px;">
          <p><strong>語音合成支持：</strong> ${voiceInfo.synthesisSupported ? '是' : '否'}</p>
          <p><strong>檢測到語音數量：</strong> ${voiceInfo.voiceCount} 個</p>
          <p><strong>zh-TW 語音：</strong> ${voiceInfo.zhTWVoice}</p>
          <p><strong>其他中文語音數量：</strong> ${voiceInfo.otherChineseVoiceCount} 個</p>
          <p><strong>設備類型：</strong> ${voiceInfo.deviceType}</p>
        </div>
        <p style="margin-bottom: 15px;">建議解決方案：</p>
        <ul style="text-align: left; margin-bottom: 20px; padding-left: 20px;">
          <li>在手機設定中安裝中文語音套件</li>
          <li>更新瀏覽器到最新版本</li>
          <li>嘗試使用不同的瀏覽器</li>
          <li>檢查設備的語音設定</li>
          <li>重新載入頁面（某些瀏覽器需要重新載入才能檢測到語音）</li>
          <li>點擊語音選擇框嘗試手動觸發語音檢測</li>
          <li>確保手機有足夠的存儲空間</li>
        </ul>
        <div style="display: flex; gap: 10px; justify-content: center;">
          <button onclick="closeVoiceMessage()" style="
            background-color: #8B4513;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
          ">我知道了</button>
          <button onclick="retryVoiceDetection()" style="
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
          ">重新檢測</button>
        </div>
      `;
    }

    // 獲取語音狀態信息
    function getVoiceStatusInfo() {
      const synthesisSupported = !!window.speechSynthesis;
      const voices = synthesisSupported ? window.speechSynthesis.getVoices() : [];
      const zhTWVoice = voices.find(voice => voice.lang === 'zh-TW');
      const otherChineseVoices = voices.filter(voice => 
        voice.lang === 'zh-CN' || voice.lang === 'zh-HK' || 
        (voice.lang.startsWith('zh') && voice.lang !== 'zh-TW')
      );
      
      // 檢測設備類型
      const userAgent = navigator.userAgent.toLowerCase();
      let deviceType = '桌面設備';
      if (/mobile|android|iphone|ipad|ipod/.test(userAgent)) {
        deviceType = '移動設備';
      }
      
      return {
        synthesisSupported,
        voiceCount: voices.length,
        zhTWVoice: zhTWVoice ? zhTWVoice.name : '無',
        otherChineseVoiceCount: otherChineseVoices.length,
        deviceType
      };
    }

    // 處理語音選擇框點擊事件
    function handleVoiceSelectClick() {
      const voiceSelect = document.getElementById('voiceSelect');
      const currentText = voiceSelect.options[0].text;
      
      // 如果顯示"載入中..."或"點擊重新檢測語音"，嘗試觸發語音檢測
      if (currentText === '載入中...' || currentText === '點擊重新檢測語音') {

        voiceSelect.innerHTML = '<option value="">檢測中...</option>';
        
        // 嘗試觸發語音列表更新
        setTimeout(() => {
          initVoices();
        }, 500);
        
        // 如果仍然沒有語音，再次嘗試
        setTimeout(() => {
          const voices = window.speechSynthesis.getVoices();
          if (voices.length === 0) {
  
            
            try {
              const testUtterance = new SpeechSynthesisUtterance('測試');
              testUtterance.lang = 'zh-TW';
              testUtterance.onend = () => {

                setTimeout(() => {
                  initVoices();
                }, 500);
              };
              testUtterance.onerror = () => {

                setTimeout(() => {
                  initVoices();
                }, 500);
              };
              
              window.speechSynthesis.speak(testUtterance);
            } catch (error) {

              voiceSelect.innerHTML = '<option value="">語音功能不可用</option>';
            }
          } else {
            initVoices();
          }
        }, 1000);
      }
    }

    // 重新檢測語音功能
    async function retryVoiceDetection() {
      
      
      // 關閉當前消息
      closeVoiceMessage();
      
      // 顯示檢測中狀態
      const voiceSelect = document.getElementById('voiceSelect');
      voiceSelect.innerHTML = '<option value="">檢測中...</option>';
      
      // 重新初始化語音合成
      await initSpeechSynthesis();
      
      // 重新初始化語音列表
      initVoices();
      
      // 如果仍然沒有語音，嘗試觸發語音列表更新
      if (!STATE.hasVoices) {

        
        // 創建一個測試語音來觸發語音列表加載
        try {
          const testUtterance = new SpeechSynthesisUtterance('');
          testUtterance.lang = 'zh-TW';
          testUtterance.onend = () => {

            setTimeout(() => {
              initVoices();
            }, 500);
          };
          testUtterance.onerror = () => {

            setTimeout(() => {
              initVoices();
            }, 500);
          };
          
          window.speechSynthesis.speak(testUtterance);
          
          // 延遲檢查
          setTimeout(() => {
            initVoices();
          }, 2000);
        } catch (error) {

        }
      }
      
      // 檢查是否現在有語音支持
      setTimeout(() => {
        if (STATE.isSpeechSynthesisSupported && STATE.hasVoices) {
  
          // 可以顯示成功消息
          alert('語音功能檢測成功！現在可以使用語音功能了。');
        } else {
          // 再次顯示詳細的錯誤信息
          setTimeout(() => {
            showVoiceNotSupportedMessage();
          }, 500);
        }
      }, 3000);
    }

    // 關閉語音不支持消息
    function closeVoiceMessage() {
      const messageDiv = document.getElementById('voice-not-supported-message');
      if (messageDiv) {
        messageDiv.remove();
      }
    }

    // 添加初始化語音列表的函數
    function initVoices() {
      const voiceSelect = document.getElementById('voiceSelect');
      
      // 檢查語音合成是否支持
      if (!window.speechSynthesis) {
        voiceSelect.innerHTML = '<option value="">語音功能不可用</option>';
        return;
      }
      
      // 獲取語音列表
      availableVoices = window.speechSynthesis.getVoices();

      
      // 第一優先：所有 zh-TW 語音（不重複，排除 Google 語音）
      const zhTWVoices = [];
      const zhTWVoiceNames = new Set();
      availableVoices.forEach(voice => {
        if ((voice.lang === 'zh-TW' || voice.lang.startsWith('zh_TW_')) && 
            !zhTWVoiceNames.has(voice.name) && 
            !voice.name.toLowerCase().includes('google')) {
          zhTWVoices.push(voice);
          zhTWVoiceNames.add(voice.name);
        }
      });
      // 第二優先：zh-CN、zh-HK 及其他 zh 開頭但不是 zh-TW 的語音（不重複且不與 zh-TW 重複，排除 Google 語音）
      const otherZhVoices = [];
      const otherZhVoiceNames = new Set();
      availableVoices.forEach(voice => {
        if (
          ((voice.lang === 'zh-CN' || voice.lang === 'zh-HK' || (voice.lang.startsWith('zh') && voice.lang !== 'zh-TW')) &&
          !zhTWVoiceNames.has(voice.name) &&
          !otherZhVoiceNames.has(voice.name) &&
          !voice.name.toLowerCase().includes('google'))
        ) {
          otherZhVoices.push(voice);
          otherZhVoiceNames.add(voice.name);
        }
      });
      // 只組合中文語音
      const allVoices = [...zhTWVoices, ...otherZhVoices];
      // 清空現有選項
      voiceSelect.innerHTML = '';
      if (allVoices.length > 0) {
        allVoices.forEach((voice, idx) => {
          const option = document.createElement('option');
          option.value = voice.name;
          option.textContent = `${voice.name} (${voice.lang})`;
          voiceSelect.appendChild(option);
        });
        STATE.currentVoice = allVoices[0];
        voiceSelect.value = STATE.currentVoice.name;
        STATE.hasVoices = true;
        STATE.voicesDetected = true; // 標記已檢測到語音
        // 確保語音合成支持狀態為 true
        STATE.isSpeechSynthesisSupported = true;
      } else {
        // 如果完全沒有語音，顯示提示信息
        const option = document.createElement('option');
        option.value = "";
        option.textContent = "未找到語音套件";
        voiceSelect.appendChild(option);
        STATE.hasVoices = false;
        // 設置語音合成支持狀態為 false
        STATE.isSpeechSynthesisSupported = false;
      }
    }

    // 添加更新語音的函數
    function updateVoice(voiceName) {
      if (!STATE.isSpeechSynthesisSupported || !STATE.hasVoices) {
        return;
      }
      
      STATE.currentVoice = availableVoices.find(voice => voice.name === voiceName);
      if (STATE.currentVoice && STATE.currentUtterance) {
        STATE.currentUtterance.voice = STATE.currentVoice;
      }
    }

    // 添加點擊事件處理
    document.addEventListener('DOMContentLoaded', function() {
      // 為所有經文行添加點擊事件
      document.querySelectorAll('.sutra-line').forEach((line) => {
        line.addEventListener('click', function() {
          // 獲取當前活動的章節
          const currentSutra = document.getElementById('sutraSelect').value;
          const contentDiv = document.getElementById('content-' + currentSutra);
          const activeChapter = contentDiv.querySelector('.chapter-content.active');
          
          if (!activeChapter) return;
          
          // 獲取當前點擊的句子在當前章節中的索引
          const lines = activeChapter.querySelectorAll('.sutra-line');
          const index = Array.from(lines).indexOf(this);
          
          // 設置當前選中的句子
          setSelectedSentence(index);
        });
      });
    });

    // 檢查 Google Apps Script 是否可用
    function isGoogleScriptAvailable() {
      return typeof google !== 'undefined' && 
             google.script && 
             google.script.run && 
             typeof google.script.run.getHomophoneDict === 'function';
    }

    // 優化添加同音字功能
    async function addHomophone(text, type, lineNumber = null, chapterTitle = null) {
      try {
        if (!text || type !== 'homophone') {
          return text;
        }

        // 檢查 Google Apps Script 是否可用
        if (!isGoogleScriptAvailable()) {
          throw new Error('Google Apps Script 服務不可用，請檢查網路連接');
        }

        const homophoneDict = await getHomophoneDict(chapterTitle, lineNumber);
        if (!homophoneDict || Object.keys(homophoneDict).length === 0) {
          console.warn('同音字字典為空或無效');
          return text;
        }

        return addHomophoneWithDict(text, homophoneDict);
      } catch (error) {
        return text;
      }
    }

    // 使用預先獲取的字典添加同音字
    function addHomophoneWithDict(text, homophoneDict) {
      try {
        if (!text || !homophoneDict || Object.keys(homophoneDict).length === 0) {
          return text;
        }

        // 使用 Map 優化查找效率
        const charMap = new Map(Object.entries(homophoneDict));
        
        // 使用 DocumentFragment 優化 DOM 操作
        const fragment = document.createDocumentFragment();
        const container = document.createElement('div');
        
        // 使用正確的方式處理 Unicode 字符（包括代理對）
        let i = 0;
        while (i < text.length) {
          // 獲取完整的 Unicode 字符（包括代理對）
          const char = text.charAt(i);
          const charCode = text.charCodeAt(i);
          
          // 檢查是否為代理對的高位
          if (charCode >= 0xD800 && charCode <= 0xDBFF && i + 1 < text.length) {
            const nextCharCode = text.charCodeAt(i + 1);
            // 檢查是否為代理對的低位
            if (nextCharCode >= 0xDC00 && nextCharCode <= 0xDFFF) {
              // 這是一個完整的代理對
              const fullChar = text.substring(i, i + 2);
              
              if (charMap.has(fullChar)) {
                const homophone = charMap.get(fullChar);
                
                const homophoneContainer = document.createElement('span');
                homophoneContainer.className = 'homophone-container';
                homophoneContainer.textContent = fullChar;
                
                const homophoneText = document.createElement('span');
                homophoneText.className = 'homophone-text';
                homophoneText.textContent = homophone;
                
                homophoneContainer.appendChild(homophoneText);
                container.appendChild(homophoneContainer);
              } else {
                container.appendChild(document.createTextNode(fullChar));
              }
              
              i += 2; // 跳過兩個字符
              continue;
            }
          }
          
          // 普通字符處理
          if (charMap.has(char)) {
            const homophone = charMap.get(char);
            
            const homophoneContainer = document.createElement('span');
            homophoneContainer.className = 'homophone-container';
            homophoneContainer.textContent = char;
            
            const homophoneText = document.createElement('span');
            homophoneText.className = 'homophone-text';
            homophoneText.textContent = homophone;
            
            homophoneContainer.appendChild(homophoneText);
            container.appendChild(homophoneContainer);
          } else {
            container.appendChild(document.createTextNode(char));
          }
          
          i++; // 移動到下一個字符
        }
        
        fragment.appendChild(container);
        const result = container.innerHTML;
        return result;
      } catch (error) {
        console.error('添加同音字時發生錯誤:', error);
        return text;
      }
    }

    // 使用優先級字典添加同音字（每個漢字獨立判斷優先級）
    async function addHomophoneWithPriority(text, lineSpecificDict, chapterDefaultDict, globalDict) {
      try {
        if (!text) {
          return text;
        }

        // 使用 DocumentFragment 優化 DOM 操作
        const fragment = document.createDocumentFragment();
        const container = document.createElement('div');
        
        let homophoneCount = 0;
        
        // 使用正確的方式處理 Unicode 字符（包括代理對）
        let i = 0;
        while (i < text.length) {
          // 獲取完整的 Unicode 字符（包括代理對）
          const char = text.charAt(i);
          const charCode = text.charCodeAt(i);
          
          // 檢查是否為代理對的高位
          if (charCode >= 0xD800 && charCode <= 0xDBFF && i + 1 < text.length) {
            const nextCharCode = text.charCodeAt(i + 1);
            // 檢查是否為代理對的低位
            if (nextCharCode >= 0xDC00 && nextCharCode <= 0xDFFF) {
              // 這是一個完整的代理對
              const fullChar = text.substring(i, i + 2);
              
              // 按優先級查找同音字
              let homophone = null;
              let source = '';
              
              if (lineSpecificDict[fullChar]) {
                homophone = lineSpecificDict[fullChar];
                source = '品名+行號';
              } else if (chapterDefaultDict[fullChar]) {
                homophone = chapterDefaultDict[fullChar];
                source = '品名預設';
              } else if (globalDict[fullChar]) {
                homophone = globalDict[fullChar];
                source = '全域預設';
              }
              
              if (homophone) {
                const homophoneContainer = document.createElement('span');
                homophoneContainer.className = 'homophone-container';
                
                // 創建漢字文本節點
                const charText = document.createTextNode(fullChar);
                homophoneContainer.appendChild(charText);
                
                const homophoneText = document.createElement('span');
                homophoneText.className = 'homophone-text';
                homophoneText.textContent = homophone;
                
                homophoneContainer.appendChild(homophoneText);
                container.appendChild(homophoneContainer);
                
                homophoneCount++;
              } else {
                container.appendChild(document.createTextNode(fullChar));
              }
              
              i += 2; // 跳過兩個字符
              continue;
            }
          }
          
          // 普通字符處理
          // 按優先級查找同音字
          let homophone = null;
          let source = '';
          
          if (lineSpecificDict[char]) {
            homophone = lineSpecificDict[char];
            source = '品名+行號';
          } else if (chapterDefaultDict[char]) {
            homophone = chapterDefaultDict[char];
            source = '品名預設';
          } else if (globalDict[char]) {
            homophone = globalDict[char];
            source = '全域預設';
          }
          
          if (homophone) {
            const homophoneContainer = document.createElement('span');
            homophoneContainer.className = 'homophone-container';
            
            // 創建漢字文本節點
            const charText = document.createTextNode(char);
            homophoneContainer.appendChild(charText);
            
            const homophoneText = document.createElement('span');
            homophoneText.className = 'homophone-text';
            homophoneText.textContent = homophone;
            
            homophoneContainer.appendChild(homophoneText);
            container.appendChild(homophoneContainer);
            
            homophoneCount++;
          } else {
            container.appendChild(document.createTextNode(char));
          }
          
          i++; // 移動到下一個字符
        }
        
        fragment.appendChild(container);
        const result = container.innerHTML;
        
        return result;
      } catch (error) {
        console.error('添加同音字時發生錯誤:', error);
        return text;
      }
    }

    // 重試同音字功能
    async function retryHomophone() {
      // 移除錯誤提示
      const errorDiv = document.querySelector('div[style*="border: 2px solid #ff6b6b"]');
      if (errorDiv) {
        errorDiv.remove();
      }
      
      // 清除緩存
      clearHomophoneCache();
      
      // 重新嘗試處理同音字
      try {
        await toggleHomophone();
      } catch (error) {
        console.error('重試同音字功能失敗:', error);
      }
    }

    // 優化獲取同音字字典 - 按需載入
    async function getHomophoneDict(chapterTitle, lineNumber) {
      try {
        // 檢查緩存是否有效（基於品名和行號的組合）
        const cacheKey = `${chapterTitle || 'global'}_${lineNumber || 'default'}`;
        const now = Date.now();
        if (homophoneDictCache && homophoneDictCache[cacheKey] && (now - lastHomophoneDictFetch) < CACHE_DURATION) {
          console.log('使用緩存的同音字字典');
          return homophoneDictCache[cacheKey];
        }
        
        // 首次載入時顯示提示
        console.log(`正在載入同音字字典 - 品名: ${chapterTitle || '全域'}, 行號: ${lineNumber || '預設'}`);

        return new Promise((resolve, reject) => {
          // 添加超時處理
          const timeout = setTimeout(() => {
            reject(new Error('同音字服務響應超時'));
          }, 10000); // 10秒超時

          google.script.run
            .withSuccessHandler((result) => {
              clearTimeout(timeout);
              
              if (!result) {
                if (!homophoneDictCache) homophoneDictCache = {};
                homophoneDictCache[cacheKey] = {};
                lastHomophoneDictFetch = now;
                resolve({});
                return;
              }
              
              if (typeof result !== 'object') {
                if (!homophoneDictCache) homophoneDictCache = {};
                homophoneDictCache[cacheKey] = {};
                lastHomophoneDictFetch = now;
                resolve({});
                return;
              }
              
              const keys = Object.keys(result);
              
              if (keys.length === 0) {
                if (!homophoneDictCache) homophoneDictCache = {};
                homophoneDictCache[cacheKey] = {};
                lastHomophoneDictFetch = now;
                resolve({});
                return;
              }
              
              if (!homophoneDictCache) homophoneDictCache = {};
              homophoneDictCache[cacheKey] = result;
              lastHomophoneDictFetch = now;
              resolve(result);
            })
            .withFailureHandler((error) => {
              clearTimeout(timeout);
              console.error('同音字服務調用失敗:', error);
              reject(new Error(`同音字服務錯誤: ${error.message || error}`));
            })
            .getHomophoneDict(chapterTitle, lineNumber);
        });
      } catch (error) {
        console.error('獲取同音字字典時發生錯誤:', error);
        throw error;
      }
    }

    // 獲取完整同音字字典結構
    async function getFullHomophoneDict() {
      try {
        return new Promise((resolve, reject) => {
          // 添加超時處理
          const timeout = setTimeout(() => {
            reject(new Error('同音字服務響應超時'));
          }, 10000); // 10秒超時

          google.script.run
            .withSuccessHandler((result) => {
              clearTimeout(timeout);
              
              if (!result) {
                resolve({});
                return;
              }
              
              if (typeof result !== 'object') {
                resolve({});
                return;
              }
              
              resolve(result);
            })
            .withFailureHandler((error) => {
              clearTimeout(timeout);
              console.error('獲取完整同音字字典失敗:', error);
              reject(new Error(`同音字服務錯誤: ${error.message || error}`));
            })
            .getFullHomophoneDict();
        });
      } catch (error) {
        console.error('獲取完整同音字字典時發生錯誤:', error);
        throw error;
      }
    }

    // ==================== 全文搜尋功能 ====================
    let currentSearchTerm = '';
    let searchMatches = [];

    // 處理搜尋輸入（防抖處理）
    const handleSearchInput = Utils.debounce((value) => {
      if (value.trim()) {
        performSearch();
      } else {
        clearSearch();
      }
    }, 300);

    // 執行搜尋
    function performSearch() {
      const searchInput = document.getElementById('searchInput');
      const searchTerm = searchInput.value.trim();
      const clearBtn = document.querySelector('.search-clear-btn');
      
      if (!searchTerm) {
        clearSearch();
        return;
      }
      
      currentSearchTerm = searchTerm;
      
      // 顯示清除按鈕
      if (clearBtn) clearBtn.style.display = 'block';
      
      // 清除之前的高亮
      document.querySelectorAll('.sutra-line.search-match').forEach(line => {
        line.classList.remove('search-match');
      });
      
      // 在當前活動的章節中搜尋
      const currentSutra = document.getElementById('sutraSelect').value;
      if (!currentSutra) {
        alert('請先選擇經文');
        return;
      }
      
      const contentDiv = document.getElementById('content-' + currentSutra);
      if (!contentDiv) {
        alert('請先載入經文內容');
        return;
      }
      
      const activeChapter = contentDiv.querySelector('.chapter-content.active');
      if (!activeChapter) {
        alert('請先選擇品名');
        return;
      }
      
      searchMatches = [];
      const lines = activeChapter.querySelectorAll('.sutra-line');
      
      lines.forEach((line, index) => {
        const textElement = line.querySelector('.original-text');
        if (textElement) {
          const text = textElement.textContent || textElement.innerText;
          if (text.includes(searchTerm)) {
            line.classList.add('search-match');
            searchMatches.push({
              line: line,
              index: index,
              text: text
            });
          }
        }
      });
      
      if (searchMatches.length > 0) {
        // 滾動到第一個匹配結果
        searchMatches[0].line.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // 高亮第一個匹配
        searchMatches[0].line.style.animation = 'pulse 0.5s ease-in-out';
        
        // 顯示搜尋結果統計
        console.log(`找到 ${searchMatches.length} 個匹配結果`);
      } else {
        alert('未找到匹配的內容');
      }
    }

    // 清除搜尋
    function clearSearch() {
      currentSearchTerm = '';
      searchMatches = [];
      const searchInput = document.getElementById('searchInput');
      const clearBtn = document.querySelector('.search-clear-btn');
      
      if (searchInput) searchInput.value = '';
      if (clearBtn) clearBtn.style.display = 'none';
      
      // 移除所有高亮
      document.querySelectorAll('.sutra-line.search-match').forEach(line => {
        line.classList.remove('search-match');
      });
    }

    // 添加搜尋動畫
    const style = document.createElement('style');
    style.textContent = `
      @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
      }
    `;
    document.head.appendChild(style);

    // ==================== 閱讀進度追蹤功能 ====================
    let lastSavedProgress = null;

    // 自動保存閱讀進度（當用戶點擊經文行時）
    function saveProgress(lineElement) {
      if (!lineElement) return;
      
      const currentSutra = document.getElementById('sutraSelect').value;
      const chapterSelect = document.getElementById('chapterSelect');
      
      if (!currentSutra || !chapterSelect || chapterSelect.value === '') return;
      
      const chapterIndex = chapterSelect.value;
      const lineNumber = lineElement.dataset.lineNumber || lineElement.getAttribute('data-line-number');
      
      if (!lineNumber) return;
      
      // 避免重複保存相同的進度
      const progressKey = `${currentSutra}_${chapterIndex}_${lineNumber}`;
      if (lastSavedProgress === progressKey) return;
      
      lastSavedProgress = progressKey;
      
      google.script.run
        .withSuccessHandler(() => {
          console.log('閱讀進度已保存');
        })
        .withFailureHandler((error) => {
          console.error('保存閱讀進度失敗:', error);
        })
        .saveReadingProgress(currentSutra, chapterIndex, lineNumber);
    }

    // 恢復閱讀進度
    function restoreReadingProgress() {
      google.script.run
        .withSuccessHandler((progress) => {
          if (!progress || !progress.current) {
            alert('沒有保存的閱讀進度');
            return;
          }
          
          const currentData = progress.current;
          
          // 確認是否要跳轉
          if (confirm(`是否要跳轉到上次閱讀位置？\n經文：${currentData.sheetName}\n行號：${currentData.lineNumber}`)) {
            // 切換到對應的經文
            const sutraSelect = document.getElementById('sutraSelect');
            if (sutraSelect.value !== currentData.sheetName) {
              sutraSelect.value = currentData.sheetName;
              changeSutra(currentData.sheetName, true).then(() => {
                // 等待內容載入後選擇品名和跳轉到行號
                setTimeout(() => {
                  const chapterSelect = document.getElementById('chapterSelect');
                  chapterSelect.value = currentData.chapterIndex;
                  handleChapterChange(currentData.chapterIndex);
                  
                  // 跳轉到指定行號
                  setTimeout(() => {
                    const contentDiv = document.getElementById('content-' + currentData.sheetName);
                    if (contentDiv) {
                      const activeChapter = contentDiv.querySelector('.chapter-content.active');
                      if (activeChapter) {
                        const targetLine = activeChapter.querySelector(`.sutra-line[data-line-number="${currentData.lineNumber}"]`);
                        if (targetLine) {
                          targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                          targetLine.classList.add('selected');
                          setTimeout(() => targetLine.classList.remove('selected'), 2000);
                        }
                      }
                    }
                  }, 500);
                }, 500);
              });
            } else {
              // 如果已經是當前經文，直接跳轉
              const chapterSelect = document.getElementById('chapterSelect');
              chapterSelect.value = currentData.chapterIndex;
              handleChapterChange(currentData.chapterIndex);
              
              setTimeout(() => {
                const contentDiv = document.getElementById('content-' + currentData.sheetName);
                if (contentDiv) {
                  const activeChapter = contentDiv.querySelector('.chapter-content.active');
                  if (activeChapter) {
                    const targetLine = activeChapter.querySelector(`.sutra-line[data-line-number="${currentData.lineNumber}"]`);
                    if (targetLine) {
                      targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                      targetLine.classList.add('selected');
                      setTimeout(() => targetLine.classList.remove('selected'), 2000);
                    }
                  }
                }
              }, 500);
            }
          }
        })
        .withFailureHandler((error) => {
          console.error('獲取閱讀進度失敗:', error);
          alert('獲取閱讀進度失敗：' + error.message);
        })
        .getReadingProgress();
    }

    // ==================== 書籤功能 ====================
    let bookmarksCache = [];

    // 載入書籤並標記
    async function loadBookmarks() {
      try {
        const bookmarks = await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            .getAllBookmarks();
        });
        
        bookmarksCache = bookmarks;
        markBookmarkedLines();
        return bookmarks;
      } catch (error) {
        console.error('載入書籤失敗:', error);
        return [];
      }
    }

    // 標記有書籤的行
    function markBookmarkedLines() {
      // 清除所有書籤標記和按鈕狀態
      document.querySelectorAll('.sutra-line.bookmarked').forEach(line => {
        line.classList.remove('bookmarked');
        const bookmarkBtn = line.querySelector('.bookmark-btn');
        if (bookmarkBtn) {
          bookmarkBtn.classList.remove('active');
        }
      });
      
      const currentSutra = document.getElementById('sutraSelect').value;
      if (!currentSutra) return;
      
      const contentDiv = document.getElementById('content-' + currentSutra);
      if (!contentDiv) return;
      
      const activeChapter = contentDiv.querySelector('.chapter-content.active');
      if (!activeChapter) return;
      
      const chapterSelect = document.getElementById('chapterSelect');
      const currentChapterIndex = chapterSelect ? chapterSelect.value : '';
      
      // 標記當前章節中有書籤的行
      bookmarksCache.forEach(bookmark => {
        if (bookmark.sheetName === currentSutra && 
            bookmark.chapterIndex === currentChapterIndex) {
          const targetLine = activeChapter.querySelector(`.sutra-line[data-line-number="${bookmark.lineNumber}"]`);
          if (targetLine) {
            targetLine.classList.add('bookmarked');
            targetLine.dataset.bookmarkId = bookmark.id;
            
            // 更新書籤按鈕狀態（手機版）
            const bookmarkBtn = targetLine.querySelector('.bookmark-btn');
            if (bookmarkBtn) {
              bookmarkBtn.classList.add('active');
            }
          }
        }
      });
    }

    // 添加書籤
    function addBookmarkToLine(lineElement) {
      if (!lineElement) return;
      
      const currentSutra = document.getElementById('sutraSelect').value;
      const chapterSelect = document.getElementById('chapterSelect');
      
      if (!currentSutra || !chapterSelect || chapterSelect.value === '') {
        alert('請先選擇經文和品名');
        return;
      }
      
      const chapterIndex = chapterSelect.value;
      const chapterTitle = chapterSelect.options[chapterSelect.selectedIndex].text;
      const lineNumber = lineElement.dataset.lineNumber || lineElement.getAttribute('data-line-number');
      const textElement = lineElement.querySelector('.original-text');
      const lineText = textElement ? (textElement.textContent || textElement.innerText) : '';
      
      google.script.run
        .withSuccessHandler((result) => {
          if (result.success) {
            alert('書籤已添加');
            loadBookmarks(); // 重新載入書籤
          } else {
            alert(result.message);
          }
        })
        .withFailureHandler((error) => {
          console.error('添加書籤失敗:', error);
          alert('添加書籤失敗：' + error.message);
        })
        .addBookmark(currentSutra, chapterIndex, chapterTitle, lineNumber, lineText);
    }

    // 刪除書籤
    function deleteBookmarkById(bookmarkId) {
      google.script.run
        .withSuccessHandler((result) => {
          if (result.success) {
            alert('書籤已刪除');
            loadBookmarks(); // 重新載入書籤
            showBookmarks(); // 刷新書籤列表
          } else {
            alert(result.message);
          }
        })
        .withFailureHandler((error) => {
          console.error('刪除書籤失敗:', error);
          alert('刪除書籤失敗：' + error.message);
        })
        .deleteBookmark(bookmarkId);
    }

    // 顯示書籤管理界面
    function showBookmarks() {
      google.script.run
        .withSuccessHandler((bookmarks) => {
          if (!bookmarks || bookmarks.length === 0) {
            alert('目前沒有書籤');
            return;
          }
          
          let bookmarkList = '書籤列表：\n\n';
          bookmarks.forEach((bookmark, index) => {
            const date = new Date(bookmark.timestamp);
            bookmarkList += `${index + 1}. ${bookmark.sheetName} - ${bookmark.chapterTitle}\n`;
            bookmarkList += `   行號：${bookmark.lineNumber}\n`;
            bookmarkList += `   時間：${date.toLocaleString('zh-TW')}\n`;
            bookmarkList += `   內容：${bookmark.lineText.substring(0, 30)}...\n\n`;
          });
          
          bookmarkList += '\n輸入要刪除的書籤編號（1-' + bookmarks.length + '），或輸入 0 跳轉到書籤：';
          
          const action = prompt(bookmarkList + '\n\n提示：Shift + Ctrl + 點擊經文行可添加/刪除書籤');
          
          if (action === null) return;
          
          const actionNum = parseInt(action);
          if (!isNaN(actionNum) && actionNum > 0 && actionNum <= bookmarks.length) {
            // 刪除書籤
            if (confirm('確定要刪除此書籤嗎？')) {
              deleteBookmarkById(bookmarks[actionNum - 1].id);
            }
          } else if (!isNaN(actionNum) && actionNum === 0) {
            // 跳轉到書籤（選擇第一個）
            if (bookmarks.length > 0) {
              const bookmark = bookmarks[0];
              const sutraSelect = document.getElementById('sutraSelect');
              sutraSelect.value = bookmark.sheetName;
              changeSutra(bookmark.sheetName, true).then(() => {
                setTimeout(() => {
                  const chapterSelect = document.getElementById('chapterSelect');
                  chapterSelect.value = bookmark.chapterIndex;
                  handleChapterChange(bookmark.chapterIndex);
                  
                  setTimeout(() => {
                    const contentDiv = document.getElementById('content-' + bookmark.sheetName);
                    if (contentDiv) {
                      const activeChapter = contentDiv.querySelector('.chapter-content.active');
                      if (activeChapter) {
                        const targetLine = activeChapter.querySelector(`.sutra-line[data-line-number="${bookmark.lineNumber}"]`);
                        if (targetLine) {
                          targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                          targetLine.classList.add('selected');
                          setTimeout(() => targetLine.classList.remove('selected'), 2000);
                        }
                      }
                    }
                  }, 500);
                }, 500);
              });
            }
          }
        })
        .withFailureHandler((error) => {
          console.error('獲取書籤失敗:', error);
          alert('獲取書籤失敗：' + error.message);
        })
        .getAllBookmarks();
    }

    // 切換書籤（手機版按鈕或電腦版快捷鍵）
    function toggleBookmark(button) {
      const sutraLine = button.closest('.sutra-line');
      if (!sutraLine) return;
      
      if (sutraLine.classList.contains('bookmarked')) {
        // 如果有書籤，刪除它
        const bookmarkId = sutraLine.dataset.bookmarkId;
        if (bookmarkId) {
          if (confirm('確定要刪除此書籤嗎？')) {
            deleteBookmarkById(bookmarkId);
          }
        }
      } else {
        // 如果沒有書籤，添加一個
        addBookmarkToLine(sutraLine);
      }
    }

    // 統一的經文行點擊事件處理（整合進度保存和書籤功能）
    document.addEventListener('click', function(e) {
      // 如果點擊的是書籤按鈕，已經有專門的處理函數，直接返回
      if (e.target.closest('.bookmark-btn')) {
        return;
      }
      
      const sutraLine = e.target.closest('.sutra-line');
      if (!sutraLine) return;
      
      // Shift + Ctrl + 點擊 = 添加/刪除書籤（電腦版快捷鍵）
      if (e.shiftKey && e.ctrlKey) {
        e.preventDefault();
        e.stopPropagation();
        toggleBookmark({ closest: () => sutraLine });
      } else {
        // 普通點擊時保存閱讀進度
        saveProgress(sutraLine);
      }
    }, true);

    // 長按事件處理（手機版書籤功能）
    let longPressTimer = null;
    let longPressTarget = null;

    document.addEventListener('touchstart', function(e) {
      const sutraLine = e.target.closest('.sutra-line');
      if (!sutraLine || e.target.closest('.bookmark-btn')) return;
      
      longPressTarget = sutraLine;
      longPressTimer = setTimeout(() => {
        // 長按超過 800ms 觸發書籤功能
        e.preventDefault();
        if (longPressTarget) {
          toggleBookmark({ closest: () => longPressTarget });
          // 觸覺反饋（如果支援）
          if (navigator.vibrate) {
            navigator.vibrate(50);
          }
        }
      }, 800);
    }, { passive: false });

    document.addEventListener('touchend', function(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      longPressTarget = null;
    });

    document.addEventListener('touchmove', function(e) {
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
      longPressTarget = null;
    });

    // 當章節切換時重新載入書籤標記
    const originalHandleChapterChange = window.handleChapterChange;
    if (originalHandleChapterChange) {
      window.handleChapterChange = function(value) {
        originalHandleChapterChange(value);
        setTimeout(() => {
          markBookmarkedLines();
        }, 300);
      };
    }

    // 當經文切換時重新載入書籤標記
    const originalChangeSutra = window.changeSutra;
    if (originalChangeSutra) {
      window.changeSutra = async function(sheetName, preserveChapterSelection) {
        await originalChangeSutra(sheetName, preserveChapterSelection);
        setTimeout(() => {
          loadBookmarks();
        }, 500);
      };
    } else {
      // 如果 changeSutra 不存在，監聽經文選擇器變化
      const sutraSelect = document.getElementById('sutraSelect');
      if (sutraSelect) {
        sutraSelect.addEventListener('change', function() {
          setTimeout(() => {
            loadBookmarks();
          }, 500);
        });
      }
    }

    // 頁面載入時自動載入書籤
    window.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        loadBookmarks();
      }, 1000);
    });

    // 搜尋框支援 Enter 鍵
    const searchInput = document.getElementById('searchInput');
    if (searchInput) {
      searchInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
    }
  </script>
</body>
</html> 
